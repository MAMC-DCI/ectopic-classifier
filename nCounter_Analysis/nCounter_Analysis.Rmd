---
title: "Analysis of nCounter Data"
always_allow_html: yes
output:
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 5
    theme: united
---


# Prepare the environment
The "Results" folder was generated and key packages were loaded.
```{r message=FALSE, warning=FALSE}
# Prepare the "Results" folder.
if(dir.exists("Results")){
  unlink("Results", recursive = TRUE, force = TRUE)
}
dir.create("Results")

# Load key packages.
library(magrittr) # Pipe operator.
library(ggplot2) # Plotting
library(cowplot) # Plotting.
theme_set(theme_cowplot())
library(ggsignif)
```


# Prepare the data
```{r message=FALSE, warning=FALSE}
# Define the location of the data.
data_path <- file.path("Data", "data.csv")

# Load the data.
raw_df <- readr::read_csv(data_path) %>%
  dplyr::filter(., `Analyte Type` == "mRNA" | is.na(`Analyte Type`)) %>%
  dplyr::select(., -`Accession #`, -`NS Probe ID`, -`Analyte Type`)
housekeeping_genes <- sort(unique(
  raw_df$`Probe Name`[raw_df$`Class Name` == "Housekeeping"]
))
genes <- sort(unique(
  raw_df$`Probe Name`[raw_df$`Class Name` == "Endogenous"]
))
raw_df <- dplyr::select(raw_df, -`Class Name`)
sample_classes <- unlist(raw_df[1,])[2:ncol(raw_df)]
sample_info <- tibble::enframe(sample_classes, "File", "Type")
raw_df <- raw_df[-1,]
raw_df <- tidyr::gather(raw_df, "File", "Count", -`Probe Name`) %>%
  dplyr::inner_join(
    ., sample_info,
    by = "File"
  ) %>%
  dplyr::mutate(
    .,
    Class = ifelse(
      `Probe Name` %in% housekeeping_genes,
      "Housekeeper", "Endogenous"
    ),
    Count = as.numeric(Count)
  )

# Define the path to the sample metadata.
meta_path <- file.path("Data","Modeling_Metadata.xls")

# Load metadata.
meta_df <- readxl::read_excel(meta_path) %>%
  dplyr::select(., -Group)

# Join the metadata to the 
# raw_df <- raw_df %>%
#   dplyr::mutate(
#     .,
#     SampleName = gsub("^.*PUL ","",File) %>% 
#       gsub("_.*$","",.) %>% 
#       paste0("PUL_", .)
#   ) %>%
#   dplyr::mutate(
#     SampleName = ifelse(!grepl("_PUL ",File), File, SampleName)
#   ) %>%
#   dplyr::select(., -File) %>%
#   dplyr::left_join(
#     ., meta_df,
#     by = c("SampleName" = "Sample")
#   )
raw_df <- raw_df %>%
  dplyr::mutate(
      SampleName = File %>%
          gsub(" ","_",.) %>%
          gsub(".*PUL_|.*PUL","",.) %>%
          gsub("_.*$","",.)
  ) %>% 
  dplyr::mutate(
    SampleName = paste0("PUL_", SampleName),
    is_pul = grepl("PUL", File)
  )
invalid_indices <- which(
  (raw_df$Type %in% c("AIUP", "ECT")) &
  !(raw_df$SampleName %in% meta_df$Sample)
)
raw_df <- raw_df[-invalid_indices,]

# Normalize the counts.
raw_df <- raw_df
for(i in unique(raw_df$`Probe Name`)){
  aiup_mean <- mean(raw_df$Count[
    (raw_df$Type == "AIUP") & (raw_df$`Probe Name` == i)
  ])
  raw_df$Count[raw_df$`Probe Name` == i] <- raw_df$Count[
    raw_df$`Probe Name` == i
  ]/aiup_mean
}
raw_df <- dplyr::rename(raw_df, NormCount = "Count")
```


# Verify normalization
```{r message=FALSE, warning=FALSE}
# Perform pairwise statistics.
loading_control_stats <- SimplifyStats::pairwise_stats(
  dplyr::filter(raw_df, Class == "Housekeeper"),
  group_cols = c("Type", "Probe Name"),
  var_cols = "NormCount",
  fxn = wilcox.test,
  two_way = TRUE
) %>%
  dplyr::filter(
    A.Type == "AIUP", B.Type == "ECT", `A.Probe Name` == `B.Probe Name`
  ) %>%
  dplyr::mutate(fdr = p.adjust(p.value, method = "fdr"))

# Save the loading control stats.
writexl::write_xlsx(
  loading_control_stats,
  file.path("Results","Loading_Control_Stats.xlsx")
)

# Display the loading control stats.
knitr::kable(loading_control_stats)
```


```{r message=FALSE, warning=FALSE, fig.height=4, fig.width=5.5}
df_means <- dplyr::filter(raw_df, Class == "Housekeeper") %>%
  dplyr::mutate(
    Type = factor(
      Type, levels = (c("AIUP","ECT","Adipose","Liver","Lung"))
    ),
    `Probe Name` = factor(
      `Probe Name`,
      levels = c("GUSB","PGK1","RPL19")
    )
  ) %>%
  dplyr::group_by(Type, `Probe Name`) %>%
  dplyr::summarise(
    N = dplyr::n(),
    SD = ifelse(N == 1, NA, sd(NormCount)),
    se = ifelse(N == 1, 0, sd(NormCount)/sqrt(N)),
    NormCount = mean(NormCount)
  ) %>%
  dplyr::ungroup()
norms_wilcox <- SimplifyStats::pairwise_stats(
  dplyr::filter(
    raw_df,
    Class == "Housekeeper"
  ) %>%
    dplyr::mutate(`Probe Name` = factor(
      `Probe Name`,
      levels = c("GUSB","PGK1","RPL19")
    )),
  group_cols = c("Probe Name", "Type"),
  var_cols = "NormCount",
  fxn = wilcox.test,
  two_way = TRUE
) %>%
  dplyr::filter(
    `A.Probe Name` == `B.Probe Name`,
    A.Type == "AIUP", B.Type == "ECT"
  ) %>%
  dplyr::rename(
    `Probe Name` = "A.Probe Name"
  ) %>%
  dplyr::select(-A.Type, -`B.Probe Name`, -B.Type)
writexl::write_xlsx(
  norms_wilcox,
  file.path("Results", "Housekeeping_Genes.xlsx")
)
plt <- ggplot(
  dplyr::filter(raw_df, Class == "Housekeeper") %>%
    dplyr::mutate(
      Type = factor(
        Type, levels = (c("AIUP","ECT","Adipose","Liver","Lung"))
      )
    ),
  aes(Type, NormCount)
)+
  ggbeeswarm::geom_quasirandom(dodge.width = 0.9)+
  geom_bar(
    data = df_means,
    mapping = aes(Type, NormCount),
    alpha = 0.3,
    stat = "identity", position = "dodge"
  )+
  geom_errorbar(
    data = df_means,
    mapping = aes(
      ymin = NormCount - se,
      ymax = NormCount + se
    ),
    position = position_dodge(width = 0.9),
    width = 0.2,
    colour = "black"
  )+
  coord_cartesian(ylim = c(0, 2.5), expand = FALSE)+
  ylab("Relative Expression")+
  theme(
    plot.margin = unit(c(0,1,0,0), "cm"),
    strip.background = element_blank(),
    axis.title.x = element_blank(),
    panel.spacing = unit(1, "lines"),
    strip.text = element_text(face = "italic")
  )+
  ylab("Relative Expression")+
  facet_wrap(~`Probe Name`, scales = "free", nrow = 3)+
  panel_border(colour = "black", size = 1.2)+
  geom_text(
    data = norms_wilcox,
    mapping = aes(
      1.5, 2,
      label = signif(p.value, 1) %>%
        as.character() %>%
        paste0("italic('p=')*", .),
      colour = NULL, group = NULL
    ),
    inherit.aes = FALSE,
    show.legend = FALSE,
    parse = TRUE, size = 3
  )

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Housekeeping genes.tiff"),
  plt,
  base_height = 4, base_width = 4.5
)

# Display the plot.
plt
```


Expression level plots were generated and saved for all genes. All of these plots were saved to the Results folder in the "IndividualGenes" directory.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Create an output folder.
out_dir <- file.path("Results","IndividualGenes")
if(dir.exists(out_dir)){
  unlink(out_dir)
}
dir.create(out_dir)

for(gene in genes){
  # Subset the data.
  mini_df <- dplyr::filter(
    raw_df, Class == "Endogenous", `Probe Name` == gene
  ) %>%
    dplyr::mutate(
      .,
      Type = factor(
        Type,
        levels = c("AIUP", "ECT", "Adipose", "Liver", "Lung")
      )
    )
  
  df_means <- mini_df %>%
  dplyr::mutate(
    Type = factor(
      Type, levels = (c("AIUP","ECT","Adipose","Liver","Lung"))
    )
  ) %>%
  dplyr::group_by(Type) %>%
  dplyr::summarise(
    N = dplyr::n(),
    SD = ifelse(N == 1, NA, sd(NormCount)),
    se = ifelse(N == 1, 0, sd(NormCount)/sqrt(N)),
    NormCount = mean(NormCount)
  ) %>%
  dplyr::ungroup()
  
  max_count <- max(mini_df$NormCount)
  upper_bound <- 1.3*max_count
  
  norms_wilcox <- SimplifyStats::pairwise_stats(
    dplyr::filter(
      mini_df,
      as.character(Type) %in% c("AIUP", "ECT")
    ) %>%
      dplyr::mutate(
        Type = factor(
          as.character(Type),
          levels = c("AIUP", "ECT")
        )
      ),
    group_cols = c("Probe Name", "Type"),
    var_cols = "NormCount",
    fxn = wilcox.test,
    two_way = TRUE
  ) %>%
    dplyr::filter(
      `A.Probe Name` == `B.Probe Name`,
      A.Type == "AIUP", B.Type == "ECT"
    ) %>%
    dplyr::rename(
      `Probe Name` = "A.Probe Name"
    ) %>%
    dplyr::select(-A.Type, -`B.Probe Name`, -B.Type)
  
  # Generate the plot.
  plt <- ggplot(
    mini_df,
    aes(Type, NormCount)
  ) + 
    ggbeeswarm::geom_quasirandom(dodge.width = 0.9)+
    geom_bar(
      data = df_means,
      mapping = aes(Type, NormCount),
      alpha = 0.3,
      stat = "identity", position = "dodge"
    )+
    geom_errorbar(
      data = df_means,
      mapping = aes(
        ymin = NormCount - se,
        ymax = NormCount + se
      ),
      position = position_dodge(width = 0.9),
      width = 0.2,
      colour = "black"
    )+
    geom_text(
      data = norms_wilcox,
      mapping = aes(
        1.5, 0.9*upper_bound,
        label = signif(p.value, 1) %>%
          as.character() %>%
          paste0("italic('p=')*", .),
        colour = NULL, group = NULL
      ),
      inherit.aes = FALSE,
      show.legend = FALSE,
      parse = TRUE, size = 3
    )+
    ggtitle(gene)+
    scale_y_continuous(limits = c(0, upper_bound))+
    coord_cartesian(ylim = c(0, upper_bound), expand = FALSE)+
    theme(axis.title.x = element_blank())+
    ylab("Relative Expression")+
    panel_border(colour = "black", size = 1.2)+
    scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
    scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))
  
  # Save the plot.
  cowplot::save_plot(
    file.path("Results", "IndividualGenes", paste0(gene, ".tiff")),
    plt,
    base_height = 4, base_width = 6.5
  )
}
```


A paneled plot, containing only the genes in the classifier, was also generated.


```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=9}
# Subset the data.
genes_of_interest <- c(
  "C20orf85", "LRRC46", "RSPH4A", "WDR49", "ZBBX"
)
mini_df <- dplyr::filter(
  raw_df, Class == "Endogenous", `Probe Name` %in% genes_of_interest
) %>%
  dplyr::mutate(
    .,
    Type = factor(
      Type,
      levels = c("AIUP", "ECT", "Adipose", "Liver", "Lung")
    )
  )

norms_wilcox <- SimplifyStats::pairwise_stats(
  dplyr::filter(
    mini_df,
    as.character(Type) %in% c("AIUP", "ECT")
  ) %>%
    dplyr::mutate(
      Type = factor(
        as.character(Type),
        levels = c("AIUP", "ECT")
      )
    ),
  group_cols = c("Probe Name", "Type"),
  var_cols = "NormCount",
  fxn = wilcox.test,
  two_way = TRUE
) %>%
  dplyr::filter(
    `A.Probe Name` == `B.Probe Name`,
    A.Type == "AIUP", B.Type == "ECT"
  ) %>%
  dplyr::rename(
    `Probe Name` = "A.Probe Name"
  ) %>%
  dplyr::select(-A.Type, -`B.Probe Name`, -B.Type)

df_means <- mini_df %>%
  dplyr::mutate(
    Type = factor(
      Type, levels = (c("AIUP","ECT","Adipose","Liver","Lung"))
    )
  ) %>%
  dplyr::group_by(Type, `Probe Name`) %>%
  dplyr::summarise(
    N = dplyr::n(),
    SD = ifelse(N == 1, NA, sd(NormCount)),
    se = ifelse(N == 1, 0, sd(NormCount)/sqrt(N)),
    NormCount = mean(NormCount)
  ) %>%
  dplyr::ungroup()

max_count <- max(mini_df$NormCount)
upper_bound <- 1.2*max_count

# Generate the plot.
plt <- ggplot(
  mini_df,
  aes(Type, NormCount)
) + 
  ggbeeswarm::geom_quasirandom(dodge.width = 0.9)+
  geom_bar(
    data = df_means,
    mapping = aes(Type, NormCount),
    alpha = 0.3,
    stat = "identity", position = "dodge"
  )+
  geom_errorbar(
    data = df_means,
    mapping = aes(
      ymin = NormCount - se,
      ymax = NormCount + se
    ),
    position = position_dodge(width = 0.9),
    width = 0.2,
    colour = "black"
  )+
  geom_text(
    data = norms_wilcox,
    mapping = aes(
      1.5, 0.9*upper_bound,
      label = signif(p.value, 1) %>%
        as.character() %>%
        paste0("italic('p=')*", .),
      colour = NULL, group = NULL
    ),
    inherit.aes = FALSE,
    show.legend = FALSE,
    parse = TRUE, size = 3
  )+
  scale_y_continuous(expand = expand_scale(
    mult = c(0, 0.25),
    add = c(0, 0)
  ))+
  facet_wrap(~`Probe Name`, scales = "free", nrow = 3)+
  # coord_cartesian(ylim = c(0, upper_bound), expand = FALSE)+
  theme(
    axis.title.x = element_blank(),
    strip.background = element_blank(),
    panel.spacing = unit(1, "lines"),
    legend.position = "top",
    legend.title = element_blank(),
    strip.text = element_text(face = "italic")
  )+
  ylab("Relative Expression")+
  panel_border(colour = "black", size = 1.2)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))

# Save the plot.
cowplot::save_plot(
  file.path("Results", "RelativeGeneExpression.tiff"),
  plt,
  base_height = 6.5, base_width = 6.5
)

#  Display the plot.
plt
```


Finally, pairwise Wilcoxon rank-sum tests were performed.
```{r message=FALSE, warning=FALSE}
# Perform pairwise statistics.
gene_stats <- SimplifyStats::pairwise_stats(
  dplyr::filter(raw_df, `Probe Name` %in% genes_of_interest),
  group_cols = c("Type", "Probe Name"),
  var_cols = "NormCount",
  fxn = wilcox.test,
  two_way = TRUE
) %>%
  dplyr::filter(
    A.Type == "AIUP", B.Type == "ECT", `A.Probe Name` == `B.Probe Name`
  ) %>%
  dplyr::mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  dplyr::rename(`Probe Name` = "A.Probe Name") %>%
  dplyr::select(-Variable, -A.Type, -B.Type, -`B.Probe Name`, -statistic)

fc_df <- dplyr::filter(raw_df, Class == "Endogenous", Type %in% c("AIUP", "ECT")) %>%
  dplyr::mutate(., Type = factor(Type, levels = c("AIUP", "ECT"))) %>%
  dplyr::group_by(., Type, `Probe Name`) %>%
  dplyr::summarise(., MEAN = mean(NormCount)) %>%
  dplyr::ungroup() %>%
  tidyr::spread(., Type, MEAN) %>%
  dplyr::mutate(., fc = ECT/AIUP, l2fc = log2(fc))

gene_stats <- dplyr::inner_join(
  gene_stats, fc_df,
  by = "Probe Name"
) %>%
  dplyr::arrange(`Probe Name`)

# Save the loading control stats.
writexl::write_xlsx(
  gene_stats,
  file.path("Results","Gene_Stats.xlsx")
)

# Display the loading control stats.
knitr::kable(gene_stats)
```


Another paneled plot like above was created. In this plot, however, the control with the intermediate mean expression level was dropped. This paneled plot is otherwise identical to the one above.


```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=9}
# Subset the data.
mini_df <- dplyr::filter(
  raw_df, Class == "Endogenous", `Probe Name` %in% genes_of_interest
) %>%
  dplyr::mutate(
    .,
    Type = factor(
      Type,
      levels = c("AIUP", "ECT", "Adipose", "Liver", "Lung")
    )
  )

df_means <- mini_df %>%
  dplyr::mutate(
    Type = factor(
      Type, levels = (c("AIUP","ECT","Adipose","Liver","Lung"))
    )
  ) %>%
  dplyr::group_by(Type, `Probe Name`) %>%
  dplyr::summarise(
    N = dplyr::n(),
    SD = ifelse(N == 1, NA, sd(NormCount)),
    se = ifelse(N == 1, 0, sd(NormCount)/sqrt(N-1)),
    NormCount = mean(NormCount)
  ) %>%
  dplyr::ungroup()

df_control_means <- df_means %>%
  dplyr::filter(!(Type %in% c("AIUP","ECT"))) %>%
  dplyr::group_by(`Probe Name`) %>%
  dplyr::summarise(Type = Type[NormCount == median(NormCount)]) %>%
  dplyr::ungroup()


df_means <- dplyr::filter(
  df_means,
  !(paste(`Probe Name`, Type) %in% paste(
    df_control_means$`Probe Name`,
    df_control_means$Type
  ))
)
mini_df <- dplyr::filter(
  mini_df,
  !(paste(`Probe Name`, Type) %in% paste(
    df_control_means$`Probe Name`,
    df_control_means$Type
  ))
)

max_count <- max(mini_df$NormCount)
upper_bound <- 1.2*max_count

# Generate the plot.
plt <- ggplot(
  mini_df,
  aes(Type, NormCount)
) + 
  ggbeeswarm::geom_quasirandom(dodge.width = 0.9)+
  geom_bar(
    data = df_means,
    mapping = aes(Type, NormCount),
    alpha = 0.3,
    stat = "identity", position = "dodge"
  )+
  geom_errorbar(
    data = df_means,
    mapping = aes(
      ymin = NormCount - se,
      ymax = NormCount + se
    ),
    position = position_dodge(width = 0.9),
    width = 0.2,
    colour = "black"
  )+
  geom_text(
    data = norms_wilcox,
    mapping = aes(
      1.5, 0.9*upper_bound,
      label = signif(p.value, 1) %>%
        as.character() %>%
        paste0("italic('p=')*", .),
      colour = NULL, group = NULL
    ),
    inherit.aes = FALSE,
    show.legend = FALSE,
    parse = TRUE, size = 4
  )+
  scale_y_continuous(expand = expand_scale(
    mult = c(0, 0.25),
    add = c(0, 0)
  ))+
  facet_wrap(~`Probe Name`, scales = "free", nrow = 3)+
  # coord_cartesian(ylim = c(0, upper_bound), expand = FALSE)+
  theme(
    axis.title.x = element_blank(),
    strip.background = element_blank(),
    panel.spacing = unit(1, "lines"),
    legend.position = "top",
    legend.title = element_blank(),
    strip.text = element_text(face = "italic")
  )+
  ylab("Relative Expression")+
  panel_border(colour = "black", size = 1.2)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))

# Save the plot.
cowplot::save_plot(
  file.path("Results", "RelativeGeneExpression_ControlPairs.tiff"),
  plt,
  base_height = 6.5, base_width = 6.5
)

#  Display the plot.
plt
```


# Predictive modeling


The data was prepared for modeling.


```{r message=FALSE, warning=FALSE}
modeling_df <- dplyr::filter(
  raw_df,
  `Probe Name` %in% genes_of_interest,
  Type %in% c("AIUP","ECT"),
  Class == "Endogenous"
) %>%
  dplyr::select(-Class) %>%
  dplyr::mutate(NormCount = log2(NormCount)) %>%
  tidyr::spread(key = `Probe Name`, value = NormCount)

writexl::write_xlsx(
  modeling_df %>%
    dplyr::select(-File, -is_pul) %>%
    tidyr::gather("Gene", "Expression", -Type, -SampleName) %>%
    dplyr::mutate(Source = "nCounter") %>%
    dplyr::rename(
      Label = "Type",
      Sample = "SampleName"
    ),
  file.path("Results", "nCounter_Normalized_Data.xlsx")
)

internal_spread <- dplyr::filter(modeling_df) %>%
  dplyr::rename(Group = "Type") %>%
  as.data.frame() %>%
  dplyr::mutate(
    Group = factor(Group, levels = c("AIUP", "ECT"))
  ) %>%
  tibble::column_to_rownames("SampleName") %>%
  dplyr::select(-is_pul, -File)
```


# Model development


```{r}
# Perform loocv to identify the optimal lambda.
ln_lambdas_tried <- seq(-10, 10, 0.01)
cv_a_glmnet <- function(current_spread, ln_lambdas_tried){
  glmnet::cv.glmnet(
    x = current_spread %>%
      dplyr::select(-Group) %>%
      as.matrix(),
    y = current_spread$Group,
    family = "binomial",
    alpha = 0,
    lambda = exp(ln_lambdas_tried),
    nfolds = nrow(current_spread),
    grouped = FALSE
  )
}
internal_cv_glmnet <- cv_a_glmnet(internal_spread, ln_lambdas_tried)

# Generate a PCA scatterplot.
plot_pca_scatter <- function(df){
  cols_to_exclude <- "Group"
  df_wo_groups <- df[,!(colnames(df) %in% cols_to_exclude)]
  pca <- FactoMineR::PCA(
    df_wo_groups, ncp = ncol(df_wo_groups), graph = FALSE, scale.unit = FALSE
  )
  df_plt <- tibble::tibble(
    Group = df$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  ggplot()+
    coord_fixed()+
    scale_x_continuous(expand = expand_scale(mult = 0.1, add = 0))+
    scale_y_continuous(expand = expand_scale(mult = 0.1, add = 0))+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    theme(
      legend.title = element_blank()
    )+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )
}

plt <- plot_pca_scatter(internal_spread)
cowplot::save_plot(
  file.path("Results", "Internal_PCA.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a scree plot.
plot_pca_scree <- function(df){
  cols_to_exclude <- "Group"
  df_wo_groups <- df[,!(colnames(df) %in% cols_to_exclude)]
  pca <- FactoMineR::PCA(
    df_wo_groups, ncp = ncol(df_wo_groups), graph = FALSE, scale.unit = FALSE
  )
  df_plt <- as.data.frame(pca$eig) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(PC = factor(dplyr::row_number()))
  
  ggplot()+
    coord_cartesian(ylim = c(0,100))+
    scale_y_continuous(expand = expand_scale(mult = 0, add = 0))+
    geom_line(
      data = df_plt,
      mapping = aes(PC, `percentage of variance`, group = 1),
      colour = "red"
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC, `percentage of variance`),
      colour = "black", size = 1.2
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab("PC")+ylab("Variance explained (%)")
}

plt <- plot_pca_scree(internal_spread)
cowplot::save_plot(
  file.path("Results", "Internal_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot the cross validation results.
plot_cv_glmnet <- function(current_cv, ln_lambdas_tried){
  df <- tibble::tibble(
    `ln(lambda)` = rev(ln_lambdas_tried),
    lambda = current_cv$lambda,
    cvm = current_cv$cvm,
    cvlo = current_cv$cvlo,
    cvup = current_cv$cvup
  )
  upper_bound <- 1.2*max(df$cvup)
  
  ggplot()+
  geom_line(
    data = df,
    mapping = aes(`ln(lambda)`, cvm),
    colour = "red", size = 1.2
  )+
  geom_line(
    data = df,
    mapping = aes(`ln(lambda)`, cvlo),
    linetype = "dashed", colour = "black", alpha = 0.8, size = 0.6
  )+
  geom_line(
    data = df,
    mapping = aes(`ln(lambda)`, cvup),
    linetype = "dashed", colour = "black", alpha = 0.8, size = 0.6
  )+
  geom_ribbon(
    data = df,
    mapping = aes(
      x = `ln(lambda)`,
      ymin = cvlo, ymax = cvup
    ),
    fill = "gray", alpha = 0.2,
  )+
  geom_vline(
    xintercept = log(current_cv$lambda.min),
    colour = "#0099ff", size = 0.8, linetype = "dashed"
  )+
  coord_cartesian(ylim = c(0,upper_bound))+
  scale_x_continuous(expand = expand_scale(mult = c(0,0), add = c(0,0)))+
  scale_y_continuous(expand = expand_scale(mult = c(0,0.15), add = c(0,0)))+
  panel_border(colour = "black", size = 1.2)+
  xlab("ln(lambda)")+ylab("Binomial Deviance")
}

plt <- plot_cv_glmnet(internal_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Internal_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Extract and save lambda values.
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = internal_cv_glmnet$lambda.min,
    labmda_1se = internal_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Internal_Lambda.xlsx")
)
```


Models were fit using the optimal lambdas.


```{r}
# Make predictions using loocv.
loocv_predictor <- function(df, cv){
  probs <- lapply(
    1:nrow(df),
    function(i){
      df_wo_i <- df[-i,] %>%
        dplyr::select(-Group) %>%
        as.matrix()
      df_i <- df[i,] %>%
        dplyr::select(-Group) %>%
        as.matrix()
      fit_internal <- glmnet::glmnet(
        x = df_wo_i,
        y = df$Group[-i],
        family = "binomial",
        alpha = 0,
        lambda = cv$lambda.min
      )
      prob <- predict(
        fit_internal,
        newx = df_i,
        type = "response"
      ) %>% as.vector()
    }
  ) %>% unlist()
  dplyr::mutate(
    df,
    Probability = probs
  ) %>%
    tibble::as_tibble()
}
internal_predictions <- loocv_predictor(internal_spread, internal_cv_glmnet)

# Create an roc prediction object for further processing.
create_roc <- function(df){
  ROCR::prediction(
    predictions = df$Probability,
    labels = as.numeric(df$Group) - 1
  )
}
internal_rocr_prediction <- create_roc(internal_predictions)

# Create an roc performance object for further processing.
create_performance <- function(rocr_prediction){
  ROCR::performance(rocr_prediction, measure = "mat")
}
internal_rocr_performance <- create_performance(internal_rocr_prediction)

# Determine the threshold that maximizes Mathhew's correlation coefficient
# (MCC).
get_threshold <- function(rocr_performance){
  which_max <- which.max(rocr_performance@y.values[[1]])
  tibble::tibble(
    Threshold = rocr_performance@x.values[[1]][which_max],
    MCC = rocr_performance@y.values[[1]][which_max]
  )
}
internal_rocr_threshold <- get_threshold(internal_rocr_performance)
writexl::write_xlsx(
  internal_rocr_threshold, file.path("Results", "Internal_Threshold.xlsx")
)

# Use the threshold determined above to label the prediction based on their
# predicted probabilities.
label_predictions <- function(df, rocr_threshold){
  threshold <- rocr_threshold$Threshold
  dplyr::mutate(
    df,
    Prediction = ifelse(Probability < threshold, "AIUP", "ECT") %>%
      factor(., levels = c("AIUP", "ECT")),
    Correct = Group == Prediction
  )
}
internal_labeled_predictions <- label_predictions(
  internal_predictions, internal_rocr_threshold
)

# Plot the performance metric (MCC).
plot_performance <- function(rocr_performance, rocr_threshold){
  df <- tibble::tibble(
    Threshold = rocr_performance@x.values[[1]],
    MCC = rocr_performance@y.values[[1]]
  )
  ggplot()+
    geom_vline(
      xintercept = rocr_threshold$Threshold,
      colour = "red", size = 0.8, linetype = "dashed"
    )+
    geom_hline(
      yintercept = 0,
      colour = "gray", size = 0.8
    )+
    geom_line(
      data = df,
      mapping = aes(Threshold, MCC)
    )+
    geom_point(
      data = df,
      mapping = aes(Threshold, MCC)
    )+
    coord_cartesian(xlim = c(0,1), ylim = c(-1,1), expand = FALSE)+
    panel_border(colour = "black", size = 1.2)+
    scale_x_continuous(
      breaks = seq(0,1,0.2),
      labels = seq(0,1,0.2)
    )+
    scale_y_continuous(
      breaks = seq(-1,1,0.5),
      labels = seq(-1,1,0.5)
    )
}

plt <- plot_performance(internal_rocr_performance, internal_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Internal_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot an ROC curve.
plot_roc <- function(df, rocr_threshold, show_threshold = TRUE){
  roc_obj <- pROC::roc(
    response = as.numeric(df$Group) - 1,
    predictor = df$Probability
  )
  roc_df <- tibble::tibble(
    sensitivity = roc_obj$sensitivities,
    `1-specificity` = 1-roc_obj$specificities
  )
  threshold_indices <- c(
    tail(which(roc_obj$thresholds <= rocr_threshold$Threshold), 1),
    head(which(roc_obj$thresholds >= rocr_threshold$Threshold), 1)
  )
  plt <- ggplot()+
    geom_path(
      data = roc_df,
      mapping = aes(`1-specificity`, sensitivity)
    )+
    coord_equal(xlim = c(0,1), ylim = c(0,1))+
    panel_border(colour = "black", size = 1.2)+
    geom_segment(
      aes(
        x = 0, y = 0,
        xend = 1, yend = 1
      ),
      colour = "black", linetype = "dashed", size = 0.5, alpha = 0.4
    )+
    xlab("1 - Specificity")+ylab("Sensitivity")
  if(show_threshold){
    if(length(threshold_indices) == 1){
      plt <- plt+
        geom_point(
          data = tibble::tibble(
            sensitivity = roc_obj$sensitivities[threshold_indices][1],
            `1-specificity` = (1-roc_obj$specificities)[threshold_indices][1]
          ),
          mapping = aes(`1-specificity`, sensitivity),
          colour = "#ff4d4d", size = 1.5
        )
    }
    if(length(threshold_indices) == 2){
      seg_ends <- tibble::tibble(
        sensitivity = roc_obj$sensitivities[threshold_indices],
        `1-specificity` = (1-roc_obj$specificities)[threshold_indices]
      )
      plt <- plt+
        geom_segment(
          mapping = aes(
            x = seg_ends$`1-specificity`[1], y = seg_ends$sensitivity[1],
            xend = seg_ends$`1-specificity`[2], yend = seg_ends$sensitivity[2]
          ),
          colour = "#ff4d4d", size = 1.5
        )
    }
  }
  plt
}

plt <- plot_roc(
  internal_predictions, internal_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Internal_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Plot multiple ROC curves in one figure.
plot_multiple_roc <- function(data_list, show_threshold = TRUE){
  # Initialize the plot.
  plt <- ggplot()+
    coord_equal(xlim = c(0,1), ylim = c(0,1))+
    panel_border(colour = "black", size = 1.2)+
    geom_segment(
      aes(
        x = 0, y = 0,
        xend = 1, yend = 1
      ),
      colour = "black", linetype = "dashed", size = 0.5, alpha = 0.4
    )+
    xlab("1 - Specificity")+ylab("Sensitivity")
  
  # Add elements for each ROC curve.
  threshold_tbl <- tibble::tibble()
  threshold_points_tbl <- tibble::tibble()
  for(group in names(data_list)){
    roc_obj <- pROC::roc(
      response = as.numeric(data_list[[group]]$df$Group) - 1,
      predictor = data_list[[group]]$df$Probability
    )
    roc_df <- tibble::tibble(
      sensitivity = roc_obj$sensitivities,
      `1-specificity` = 1-roc_obj$specificities
    )
    threshold_indices <- c(
      tail(which(roc_obj$thresholds <= 
                   data_list[[group]]$rocr_threshold$Threshold), 1),
      head(which(roc_obj$thresholds >= 
                   data_list[[group]]$rocr_threshold$Threshold), 1)
    ) %>% sort()
    plt <- plt+
      geom_path(
        data = roc_df,
        mapping = aes(`1-specificity`, sensitivity),
        colour = data_list[[group]]$colour,
        size = 1.2
      )
    if(show_threshold){
      if(length(threshold_indices) == 1){
        threshold_points_tbl <- dplyr::bind_rows(
          threshold_points_tbl,
          tibble::tibble(
            x = (1-roc_obj$specificities)[threshold_indices][1],
            y = roc_obj$sensitivities[threshold_indices][1]
          )
        )
      }
      if(length(threshold_indices) == 2){
        seg_ends <- tibble::tibble(
          sensitivity = roc_obj$sensitivities[threshold_indices],
          `1-specificity` = (1-roc_obj$specificities)[threshold_indices]
        )
        threshold_tbl <- dplyr::bind_rows(
          threshold_tbl,
          tibble::tibble(
            x = seg_ends$`1-specificity`[1],
            y = seg_ends$sensitivity[1],
            xend = seg_ends$`1-specificity`[2],
            yend = seg_ends$sensitivity[2]
          )
        )
      }
    }
  }
  if(show_threshold){
    if(nrow(threshold_tbl) > 0){
      plt <- plt+
        geom_segment(
          data = threshold_tbl,
          mapping = aes(x = x, y = y, xend = xend, yend = yend),
          colour = "black", size = 1.5
        )
    }
    if(nrow(threshold_points_tbl) > 0){
      plt <- plt+
        geom_point(
          data = threshold_points_tbl,
          mapping = aes(x, y),
          colour = "black", size = 1.5
        )
    }
  }
  colour_values <- sapply(data_list, function(x){x[["colour"]]})
  plt+
    geom_line(
      data = tibble::tibble(
        group = factor(rep(names(data_list),2), levels = names(data_list)),
        x = rep(c(-1,-2), each = length(data_list)),
        y = rep(c(-1,-2), each = length(data_list))
      ),
      mapping = aes(x, y, colour = group),
      show.legend = TRUE,
      size = 1.2
    )+
    scale_colour_manual(
      name = "Legend",
      values = colour_values
    )+
    theme(
      legend.position = "right",
      legend.title = element_blank()
    )
}

# Retrieve ROC curve-related statistics.
get_roc_stats <- function(df, rocr_threshold){
  roc_obj <- pROC::roc(
    response = as.numeric(df$Group) - 1,
    predictor = df$Probability
  )
  threshold_indices <- c(
    tail(which(roc_obj$thresholds <= rocr_threshold$Threshold), 1),
    head(which(roc_obj$thresholds >= rocr_threshold$Threshold), 1)
  )
  sensitivity <- mean(roc_obj$sensitivities[threshold_indices])
  specificity <- mean(roc_obj$specificities[threshold_indices])
  auc <- pROC::ci.auc(roc_obj)
  se <- pROC::ci.se(roc_obj, specificities = specificity)
  se <- se[1:3]
  sp <- pROC::ci.sp(roc_obj, sensitivities = sensitivity)
  sp <- sp[1:3]
  
  out <- tibble::tibble(
    auc = paste0(
      signif(median(auc), 2), " (", signif(min(auc), 2), ", ", 
      signif(max(auc), 2), ")"
    ),
    se = paste0(
      signif(median(se), 2), " (", signif(min(se), 2), ", ", 
      signif(max(se), 2), ")"
    ),
    sp = paste0(
      signif(median(sp), 2), " (", signif(min(sp), 2), ", ", 
      signif(max(sp), 2), ")"
    )
  )
  out
}

internal_roc_stats <- get_roc_stats(
  internal_predictions, internal_rocr_threshold
)
writexl::write_xlsx(
  internal_roc_stats,
  file.path("Results", "Internal_ROC_Stats.xlsx")
)

# Calculate accuracy on boostrapped samples.
sample_accuracy <- function(df, num_trials, SEED = 123456789){
  set.seed(SEED)
  N <- nrow(df)
  prob <- mean(df$Correct)
  probs <- c(1-prob, prob)
  sigma <- sqrt(prod(probs)/N)
  
  accepted_probs <- vector(mode = "numeric", length = num_trials)
  i <- 1
  while(i < num_trials){
    rand_number <- runif(1)
    z_value <- (rand_number-prob)/sigma
    
    quantiles <- pnorm(abs(z_value), lower.tail = FALSE)*2
    new_rand_number <- runif(1)
    
    accepted <- quantiles > new_rand_number
    
    if(accepted){
      accepted_probs[i] <- rand_number
      i <- i + 1
    }
  }
  return(accepted_probs)
}

num_trials <- 100000
internal_sampled_accuracy <- sample_accuracy(
  internal_labeled_predictions, num_trials
)

# Use the bootstrap results above to calculate the accuracy CI.
get_accuracy_ci <- function(sampled_accuracy, confidence_level = 0.95){
  low_q <- (1-confidence_level)/2
  high_q <- 1-low_q
  MEAN <- mean(sampled_accuracy)
  quantiles <- quantile(sampled_accuracy, c(low_q, high_q))
  LOW <- quantiles[1]
  HIGH <- quantiles[2]
  tibble::tibble(
    accuracy = paste0(
      signif(MEAN, 2), " (", signif(LOW, 2), ", ", signif(HIGH, 2), ")"
    )
  )
}

internal_accuracy_ci <- get_accuracy_ci(
  internal_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  internal_accuracy_ci,
  file.path("Results", "Internal_Accuracy_CI.xlsx")
)

# Plot the accuracy CI.
plot_accuracy_ci <- function(sampled_accuracy, accuracy_ci){
  accuracy_points <- strsplit(accuracy_ci$accuracy, " |, ")[[1]] %>%
    gsub("\\(","",.) %>%
    gsub("\\)","",.) %>%
    as.numeric()
  value_counts <- table(sampled_accuracy) %>%
    tibble::enframe() %>%
    dplyr::rename(Accuracy = "name", Counts = "value") %>%
    dplyr::mutate(
      Counts = as.vector(Counts),
      Accuracy = as.numeric(Accuracy)
    ) %>%
    dplyr::arrange(Accuracy) %>%
    dplyr::mutate(Density = Counts/sum(Counts))
  ggplot()+
    geom_ribbon(
      data = tibble::tibble(
        x = c(accuracy_points[2], accuracy_points[3]),
        ymin = 0, ymax = Inf
      ),
      mapping = aes(x, ymin = ymin, ymax = ymax),
      fill = "#6E6E6E", alpha = 0.2
    )+
    geom_histogram(
      data = value_counts,
      mapping = aes(Accuracy, y = ..density..),
      fill = "#6BC4FF", alpha = 1,
      bins = 1000
    )+
    geom_vline(
      xintercept = accuracy_points[1],
      colour = "red", size = 1.2
    )+
    geom_vline(
      xintercept = accuracy_points[2],
      colour = "black", size = 0.8, linetype = "dashed"
    )+
    geom_vline(
      xintercept = accuracy_points[3],
      colour = "black", size = 0.8, linetype = "dashed"
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab("Accuracy (%)")+ylab("Probability Density")+
    coord_cartesian(xlim = c(0,1))+
    scale_x_continuous(
      breaks = seq(0,1,0.25),
      labels = seq(0,100, 25),
      expand = expand_scale(mult = c(0,0), add = c(0,0))
    )+
    scale_y_continuous(
      expand = expand_scale(
        mult = c(0,0.1),
        add = c(0,0)
      )
    )+
    theme(
      plot.margin = margin(r = 0.5, unit = "cm")
    )
}

plt <- plot_accuracy_ci(internal_sampled_accuracy, internal_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Internal_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Define a function for making predictions on a second data set.
partition_predictor <- function(df1, df2, cv){
  mat1 <- df1 %>%
    dplyr::select(-Group) %>%
    as.matrix()
  mat2 <- df2 %>%
    dplyr::select(-Group) %>%
    as.matrix()
  fit_internal <- glmnet::glmnet(
        x = mat1,
        y = df1$Group,
        family = "binomial",
        alpha = 0,
        lambda = cv$lambda.min
      )
  probs <- predict(
    fit_internal,
    newx = mat2,
    type = "response"
  ) %>% as.vector()
  dplyr::mutate(
    df2,
    Probability = probs
  ) %>%
    tibble::as_tibble()
}

# Perform PCA and plot the results.
plot_pca_probs <- function(df, cv, rocr_threshold){
  cols_to_exclude <- "Group"
  df_wo_groups <- df[,!(colnames(df) %in% cols_to_exclude)]
  col_means <- colMeans(df_wo_groups)
  for(i in 1:ncol(df_wo_groups)){
    df_wo_groups[[i]] <- df_wo_groups[[i]]-col_means[i]
  }
  pca <- FactoMineR::PCA(
    df_wo_groups, ncp = ncol(df_wo_groups), graph = FALSE,
    scale.unit = FALSE
  )
  df_plt <- tibble::tibble(
    Group = df$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  x_range <- range(df_plt$PC1)
  x_mid <- mean(x_range)
  y_range <- range(df_plt$PC2)
  y_mid <- mean(y_range)
  
  x_range <- diff(x_range)
  y_range <- diff(y_range)
  
  x_low <- x_mid-x_range/2*1.1
  x_hi <- x_mid+x_range/2*1.1
  y_low <- y_mid-y_range/2*1.1
  y_hi <- y_mid+y_range/2*1.1
  
  res <- 1000
  
  pc_values <- expand.grid(
    "PC1" = seq(x_low, x_hi, length.out = res),
    "PC2" = seq(y_low, y_hi, length.out = res)
  ) %>%
    tibble::as_tibble()
  
  pc_mat <- as.matrix(pc_values)
  
  hat <- pc_mat %*% t(pca$svd$V[,1:2])
  colnames(hat) <- colnames(df_wo_groups)
  
  fit_internal <- glmnet::glmnet(
    x = as.matrix(df_wo_groups),
    y = df$Group,
    family = "binomial",
    alpha = 0,
    lambda = cv$lambda.min
  )
  probs <- predict(
    fit_internal,
    newx = hat,
    type = "response"
  ) %>% as.vector()
  pc_values <- dplyr::mutate(
    pc_values,
    Probability = probs
  ) %>%
    tibble::as_tibble()
  cutoff <- 0.01
  threshold_df <- dplyr::filter(
    pc_values,
    abs(Probability - rocr_threshold$Threshold) < cutoff
  )
  
  boundary_fit <- lm(PC2 ~ PC1, data = threshold_df)
  col_getter <- colorRampPalette(c("white","black"))
  
  ggplot()+
    coord_fixed(expand = FALSE)+
    geom_tile(
      data = pc_values,
      mapping = aes(PC1, PC2, fill = Probability)
    )+
    # scale_fill_gradient(low = "white", high = "green")+
    scale_fill_gradientn(
      colours = col_getter(1000),
      na.value = "transparent",
      breaks = c(0,0.5,1),
      labels = c(0,0.5,1),
      limits = c(0,1)
    )+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_abline(
      intercept = boundary_fit$coefficients[1],
      slope = boundary_fit$coefficients[2],
      show.legend = FALSE,
      colour = "red", size = 0.6, linetype = "dashed"
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )+
    labs(fill = "Ectopic\nProbability", colour = "Location")
}

plt <- plot_pca_probs(
  internal_spread, internal_cv_glmnet, internal_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Internal_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Output labeled predictions.
writexl::write_xlsx(
  dplyr::mutate(
      internal_labeled_predictions,
      Unique_ID = rownames(internal_spread),
      Dataset = "Internal"
    ),
  file.path("Results", "Internal_Samples.xlsx")
)
```




# Model development with a smaller subset of genes


```{r}
# Subset the genes of interest.
sub_cols <- c(
  "Group",
  
  "C20orf85", "LRRC46", "ZBBX"
)
sub_internal_spread <- internal_spread[,colnames(internal_spread) %in% sub_cols]

# Perform loocv to identify the optimal lambda.
ln_lambdas_tried <- seq(-10, 10, 0.01)
internal_cv_glmnet <- cv_a_glmnet(internal_spread, ln_lambdas_tried)

# Plot the cross validation results.
plt <- plot_cv_glmnet(internal_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Post_Internal_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Extract and save lambda values.
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = internal_cv_glmnet$lambda.min,
    labmda_1se = internal_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Post_Internal_Lambda.xlsx")
)
```


Models were fit using the optimal lambdas.


```{r}
# Make predictions using loocv.
internal_predictions <- loocv_predictor(sub_internal_spread, internal_cv_glmnet)

# Create an roc prediction object for further processing.
internal_rocr_prediction <- create_roc(internal_predictions)

# Create an roc performance object for further processing.
internal_rocr_performance <- create_performance(internal_rocr_prediction)

# Determine the threshold that maximizes Mathhew's correlation coefficient
# (MCC).
internal_rocr_threshold <- get_threshold(internal_rocr_performance)
writexl::write_xlsx(
  internal_rocr_threshold, file.path("Results", "Post_Threshold.xlsx")
)

# Use the threshold determined above to label the prediction based on their
# predicted probabilities.
internal_labeled_predictions <- label_predictions(
  internal_predictions, internal_rocr_threshold
)

# Plot the performance metric (MCC).
plt <- plot_performance(internal_rocr_performance, internal_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Post_Internal_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot an ROC curve.
plt <- plot_roc(
  internal_predictions, internal_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Post_Internal_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Retrieve ROC curve-related statistics.
internal_roc_stats <- get_roc_stats(
  internal_predictions, internal_rocr_threshold
)
writexl::write_xlsx(
  internal_roc_stats,
  file.path("Results", "Post_Internal_ROC_Stats.xlsx")
)

# Calculate accuracy on boostrapped samples.
num_trials <- 100000
internal_sampled_accuracy <- sample_accuracy(
  internal_labeled_predictions, num_trials
)

# Use the bootstrap results above to calculate the accuracy CI.
internal_accuracy_ci <- get_accuracy_ci(
  internal_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  internal_accuracy_ci,
  file.path("Results", "Post_Internal_Accuracy_CI.xlsx")
)

# Plot the accuracy CI.
plt <- plot_accuracy_ci(internal_sampled_accuracy, internal_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Post_Internal_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a PCA scatterplot.
plt <- plot_pca_scatter(internal_spread)
cowplot::save_plot(
  file.path("Results", "Post_Internal_PCA.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a scree plot.
plt <- plot_pca_scree(internal_spread)
cowplot::save_plot(
  file.path("Results", "Post_Internal_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

plt <- plot_pca_probs(
  internal_spread, internal_cv_glmnet, internal_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Post_Internal_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Output labeled predictions.
writexl::write_xlsx(
  dplyr::mutate(
    internal_labeled_predictions,
    Unique_ID = rownames(internal_spread),
    Dataset = "Internal"
  ),
  file.path("Results", "Post_Samples.xlsx")
)
```



# Model development with data partitioning - internal


```{r}
# Perform loocv to identify the optimal lambda.
ln_lambdas_tried <- seq(-20, 20, 0.01)

are_aiup <- which(internal_spread$Group == "AIUP")
are_ect <- which(internal_spread$Group == "ECT")

set.seed(123456789)

train_indices <- c(
  sample(are_aiup, length(are_aiup)*0.6),
  sample(are_ect, length(are_ect)*0.6)
)

train_spread <- internal_spread[train_indices,]
test_spread <- internal_spread[-train_indices,]

train_cv_glmnet <- cv_a_glmnet(train_spread, ln_lambdas_tried)

# Plot the cross validation results.
plt <- plot_cv_glmnet(train_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Extract and save lambda values.
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = train_cv_glmnet$lambda.min,
    labmda_1se = train_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Partition_Internal_Train_Lambda.xlsx")
)
```


Models were fit using the optimal lambdas.


```{r}
# Make predictions.
train_predictions <- loocv_predictor(train_spread, train_cv_glmnet)
test_predictions <- partition_predictor(
  train_spread, test_spread, train_cv_glmnet
)

# Create an roc prediction object for further processing.
train_rocr_prediction <- create_roc(train_predictions)
test_rocr_prediction <- create_roc(test_predictions)

# Create an roc performance object for further processing.
train_rocr_performance <- create_performance(train_rocr_prediction)
test_rocr_performance <- create_performance(test_rocr_prediction)

# Determine the threshold that maximizes Mathhew's correlation coefficient
# (MCC).
train_rocr_threshold <- get_threshold(train_rocr_performance)
writexl::write_xlsx(
  internal_rocr_threshold, file.path("Results", "Partition_Threshold.xlsx")
)
test_rocr_threshold <- get_threshold(test_rocr_performance)

# Use the threshold determined above to label the prediction based on their
# predicted probabilities.
train_labeled_predictions <- label_predictions(
  train_predictions, train_rocr_threshold
)
test_labeled_predictions <- label_predictions(
  test_predictions, train_rocr_threshold
)

# Plot the performance metric (MCC).
plt <- plot_performance(train_rocr_performance, train_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_performance(test_rocr_performance, train_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Test_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot an ROC curve.
plt <- plot_roc(
  train_predictions, train_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)
plt <- plot_roc(
  test_predictions, test_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Post_Test_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Plot multiple ROC curves in one figure.
plt <- plot_multiple_roc(
  list(
    "Train" = list("df" = train_predictions, 
                   "rocr_threshold" = train_rocr_threshold,
                   "colour" = "#ff4d4d"),
    "Test" = list("df" = test_predictions, 
                  "rocr_threshold" = train_rocr_threshold,
                  "colour" = "#0099ff")
  ),
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Merged_ROC.tiff"),
  plt,
  base_width = 5.5, base_height = 4
)

# Retrieve ROC curve-related statistics.
train_roc_stats <- get_roc_stats(
  train_predictions, train_rocr_threshold
)
writexl::write_xlsx(
  train_roc_stats,
  file.path("Results", "Partition_Internal_Train_ROC_Stats.xlsx")
)
test_roc_stats <- get_roc_stats(
  test_predictions, train_rocr_threshold
)
writexl::write_xlsx(
  test_roc_stats,
  file.path("Results", "Partition_Internal_Test_ROC_Stats.xlsx")
)

# Calculate accuracy on boostrapped samples.
num_trials <- 100000
train_sampled_accuracy <- sample_accuracy(
  train_labeled_predictions, num_trials
)
test_sampled_accuracy <- sample_accuracy(
  test_labeled_predictions, num_trials
)

# Use the bootstrap results above to calculate the accuracy CI.
train_accuracy_ci <- get_accuracy_ci(
  train_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  train_accuracy_ci,
  file.path("Results", "Partition_Internal_Train_Accuracy_CI.xlsx")
)
test_accuracy_ci <- get_accuracy_ci(
  test_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  test_accuracy_ci,
  file.path("Results", "Partition_Internal_Test_Accuracy_CI.xlsx")
)

# Plot the accuracy CI.
plt <- plot_accuracy_ci(train_sampled_accuracy, train_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_accuracy_ci(test_sampled_accuracy, test_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Test_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a scree plot.
plt <- plot_pca_scree(train_spread)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)



# Perform PCA and plot the results.
plot_multiple_pca_probs <- function(df1, df2, cv, rocr_threshold){
  cols_to_exclude <- "Group"
  df1_wo_groups <- df1[,!(colnames(df1) %in% cols_to_exclude)]
  df2_wo_groups <- df2[,!(colnames(df2) %in% cols_to_exclude)]
  col_means <- colMeans(df1_wo_groups)
  for(i in 1:ncol(df1_wo_groups)){
    df1_wo_groups[[i]] <- df1_wo_groups[[i]]-col_means[i]
    df2_wo_groups[[i]] <- df2_wo_groups[[i]]-col_means[i]
  }
  pca <- FactoMineR::PCA(
    df1_wo_groups, ncp = ncol(df1_wo_groups), graph = FALSE,
    scale.unit = FALSE
  )
  df1_plt <- tibble::tibble(
    Group = df1$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  pca2 <- FactoMineR::predict.PCA(pca, df2_wo_groups)
  df2_plt <- tibble::tibble(
    Group = df2$Group,
    PC1 = pca2$coord[,1],
    PC2 = pca2$coord[,2]
  )
  
  df_plt <- dplyr::bind_rows(
    dplyr::mutate(df1_plt, Dataset = "Train"),
    dplyr::mutate(df2_plt, Dataset = "Test")
  ) %>%
    dplyr::mutate(Dataset = factor(Dataset, levels = c("Train", "Test")))
  
  x_range <- range(df_plt$PC1)
  x_mid <- mean(x_range)
  y_range <- range(df_plt$PC2)
  y_mid <- mean(y_range)
  
  x_range <- diff(x_range)
  y_range <- diff(y_range)
  
  x_low <- x_mid-x_range/2*1.1
  x_hi <- x_mid+x_range/2*1.1
  y_low <- y_mid-y_range/2*1.1
  y_hi <- y_mid+y_range/2*1.1
  
  res <- 1000
  
  pc_values <- expand.grid(
    "PC1" = seq(x_low, x_hi, length.out = res),
    "PC2" = seq(y_low, y_hi, length.out = res)
  ) %>%
    tibble::as_tibble()
  
  pc_mat <- as.matrix(pc_values)
  
  hat <- pc_mat %*% t(pca$svd$V[,1:2])
  colnames(hat) <- colnames(df1_wo_groups)
  
  fit_internal <- glmnet::glmnet(
    x = as.matrix(df1_wo_groups),
    y = df1$Group,
    family = "binomial",
    alpha = 0,
    lambda = cv$lambda.min
  )
  probs <- predict(
    fit_internal,
    newx = hat,
    type = "response"
  ) %>% as.vector()
  pc_values <- dplyr::mutate(
    pc_values,
    Probability = probs
  ) %>%
    tibble::as_tibble()
  cutoff <- 0.01
  threshold_df <- dplyr::filter(
    pc_values,
    abs(Probability - rocr_threshold$Threshold) < cutoff
  )
  
  boundary_fit <- lm(PC2 ~ PC1, data = threshold_df)
  col_getter <- colorRampPalette(c("white","black"))
  
  ggplot()+
    coord_fixed(expand = FALSE)+
    geom_tile(
      data = pc_values,
      mapping = aes(PC1, PC2, fill = Probability)
    )+
    # scale_fill_gradient(low = "white", high = "green")+
    scale_fill_gradientn(
      colours = col_getter(1000),
      na.value = "transparent",
      breaks = c(0,0.5,1),
      labels = c(0,0.5,1),
      limits = c(0,1)
    )+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_abline(
      intercept = boundary_fit$coefficients[1],
      slope = boundary_fit$coefficients[2],
      show.legend = FALSE,
      colour = "red", size = 0.6, linetype = "dashed"
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group, shape = Dataset)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )+
    labs(fill = "Ectopic\nProbability", colour = "Location")
}

plt <- plot_multiple_pca_probs(
  train_spread, test_spread, train_cv_glmnet, train_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4.5
)

# Perform PCA and plot the results.
plot_multiple_pca_scatter <- function(df1, df2){
  cols_to_exclude <- "Group"
  df1_wo_groups <- df1[,!(colnames(df1) %in% cols_to_exclude)]
  df2_wo_groups <- df2[,!(colnames(df2) %in% cols_to_exclude)]
  col_means <- colMeans(df1_wo_groups)
  for(i in 1:ncol(df1_wo_groups)){
    df1_wo_groups[[i]] <- df1_wo_groups[[i]]-col_means[i]
    df2_wo_groups[[i]] <- df2_wo_groups[[i]]-col_means[i]
  }
  pca <- FactoMineR::PCA(
    df1_wo_groups, ncp = ncol(df1_wo_groups), graph = FALSE,
    scale.unit = FALSE
  )
  df1_plt <- tibble::tibble(
    Group = df1$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  pca2 <- FactoMineR::predict.PCA(pca, df2_wo_groups)
  df2_plt <- tibble::tibble(
    Group = df2$Group,
    PC1 = pca2$coord[,1],
    PC2 = pca2$coord[,2]
  )
  
  df_plt <- dplyr::bind_rows(
    dplyr::mutate(df1_plt, Dataset = "Train"),
    dplyr::mutate(df2_plt, Dataset = "Test")
  ) %>%
    dplyr::mutate(Dataset = factor(Dataset, levels = c("Train", "Test")))
  
  x_range <- range(df_plt$PC1)
  x_mid <- mean(x_range)
  y_range <- range(df_plt$PC2)
  y_mid <- mean(y_range)
  
  x_range <- diff(x_range)
  y_range <- diff(y_range)
  
  x_low <- x_mid-x_range/2*1.1
  x_hi <- x_mid+x_range/2*1.1
  y_low <- y_mid-y_range/2*1.1
  y_hi <- y_mid+y_range/2*1.1
  
  ggplot()+
    coord_fixed(expand = FALSE)+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group, shape = Dataset)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )+
    labs(fill = "Ectopic\nProbability", colour = "Location")
}

plt <-  plot_multiple_pca_scatter(
  train_spread, test_spread
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_PCA_Scatter.tiff"),
  plt,
  base_width = 6.5, base_height = 4.5
)

# Output labeled predictions.
writexl::write_xlsx(
  dplyr::bind_rows(
    dplyr::mutate(
      train_labeled_predictions,
      Unique_ID = rownames(train_spread),
      Dataset = "Train"
    ),
    dplyr::mutate(
      test_labeled_predictions,
      Unique_ID = rownames(test_spread),
      Dataset = "Test"
    )
  ),
  file.path("Results", "Partition_Internal_Samples.xlsx")
)
```


End of analysis.
