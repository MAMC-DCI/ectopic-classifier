---
title: "Analysis of Microarray Data"
always_allow_html: yes
output:
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 5
    theme: united
---


# Analysis overview
The principal objective of this project is to train a model that can predict whether a patient has an abnormal intrauterine pregnancy (AIUP) or ectopic pregnancy (EP) based on the transcriptomic profiles of endometrial pipelle tissue samples. Microarray data from three data sets were used in this analysis. We collected data in two phases, a discovery phase (to generate training data) and a validation phase (to generate testing data). We validated our predictive model on previously published, publicly available data from the Horne lab (["*Ectopic Pregnancy as a Model to Identify Endometrial Genes and Signaling Pathways Important in Decidualization and Regulated by Local Trophoblast*" by Duncan, Shaw, Burgess, McDonald, Critchley, and Horne.](https://doi.org/10.1371/journal.pone.0023595) (https://doi.org/10.1371/journal.pone.0023595)).


# Acquisition of microarray annotation data
The GeneChip Array Annotation files for our two studies (HuGene-2_0-st-v1 Probeset Annotations, CSV Format, Release 36) were downloaded from ThermoFisher Scientific on August 30, 2018.


The GeneChip Array Annotation files for the Horne lab array data A-AFFY-44 - Affymetrix GeneChip Human Genome U133 Plus 2.0 [HG-U133_Plus_2] were downloaded from ArrayExpress on September 9, 2018.


```{r message=FALSE, warning=FALSE, include=FALSE}
# Determine how the file is being knitted.
doc_type <- knitr::opts_knit$get("rmarkdown.pandoc.to")
if(is.null(doc_type)) doc_type <- "html"
```


# Environment setup
## Package loading
Note that, for clarity, most functions in this analysis are accessed using :: notation. Thus, packages besides those listed below are also used. The plotting packages are attached for convenience and the analysis packages are attached because several functions require it.
```{r,warning=FALSE,message=FALSE}
# Pipe operator.
library(magrittr)

# Graphing.
library(cowplot)
library(plotly)
library(ggsignif)

# Array handling.
library(affy)
library(oligo)

# Differential expression analysis.
library(limma)

# Human gene annotations.
library(org.Hs.eg.db)
library(hugene20sttranscriptcluster.db)
```


## Directory setup
The Cache and Results directories were created. The Cache folder is for holding non-results data, primarily to facilitate parallelization and/or memory management. The Results folder contains analysis results (figures, tables, etc.).
```{r message=FALSE, warning=FALSE}
source(file.path("Scripts", "PrepareDirectory.R"))
```


# Metadata management
Metadata were processed using the `process_metadata` function located in the file *ReadMetadata_functions.R* within the *Scripts* directory. Processed files were then loaded.
```{r message=FALSE, warning=FALSE, results='hide'}
# Specify the minimum RIN score.
min_rin <- 9

# Source the ReadMetadata_functions.R file.
source(file.path("Scripts","ReadMetadata_functions.R"))

# Process the metadata files.
process_metadata("MAMC_DCI__Train", min_rin)
process_metadata("MAMC_DCI__Test", min_rin)
process_metadata("MAMC_DCI__Test_RepOfTrain", min_rin)
process_metadata("Horne_Lab", min_rin)

# Load the processed metadata.
meta_train <- load_metadata("MAMC_DCI__Train")
meta_test <- load_metadata("MAMC_DCI__Test")
meta_testRepOfTrain <- load_metadata("MAMC_DCI__Test_RepOfTrain")
meta_horne <- load_metadata("Horne_Lab")

# Save the metadata.
writexl::write_xlsx(
  meta_train@data %>% tibble::rownames_to_column(., "Sample"),
  file.path("Results","Meta_train.xlsx")
)
writexl::write_xlsx(
  meta_test@data %>%
    tibble::rownames_to_column(., "Sample") %>%
    dplyr::select(., -PUL),
  file.path("Results","Meta_test.xlsx")
)
writexl::write_xlsx(
  meta_horne@data %>%
    tibble::rownames_to_column(., "Sample"),
  file.path("Results","Meta_horne.xlsx")
)
```


# Read array data
The array data for each of the four data sets was loaded and background corrected. At this stage, normalization was not performed.
```{r message=FALSE, warning=FALSE, results='hide'}
# Source the LoadArray_functions.R file.
source(file.path("Scripts","LoadArray_functions.R"))

# Load array data and perform background corrections.
raw_train <- load_arrays("MAMC_DCI__Train")
raw_test <- load_arrays("MAMC_DCI__Test")
raw_testRepOfTrain <- load_arrays("MAMC_DCI__Test_RepOfTrain")
raw_horne <- load_arrays("Horne_Lab")


# Create RMA outputs for GEO.
discovery_geo <- oligo::rma( # Identify probes removed during normalization.
  raw_train, 
  background = TRUE,
  normalize = TRUE,
  target = "core"
)
prospective_geo <- oligo::rma( # Identify probes removed during normalization.
  oligo::read.celfiles(
    filenames = c(# Read in prospective and replicate samples.
      list.files(
        file.path("Data","Arrays","MAMC_DCI","Test","CEL_files"),
        full.names = TRUE
      ),
      list.files(
        file.path("Data","Arrays","MAMC_DCI","Test_RepOfTrain","CEL_files"),
        full.names = TRUE
      )
    )
  ), 
  background = TRUE,
  normalize = TRUE,
  target = "core"
)
write.table(
  as.data.frame(as.matrix(discovery_geo)),
  file.path("Results","RMA_Discovery.txt"),
  sep = "\t", col.names = NA
)
write.table(
  as.data.frame(as.matrix(prospective_geo)),
  file.path("Results","RMA_Prospective.txt"),
  sep = "\t", col.names = NA
)
```


# Create maps between gene symbols, ENSEMBL IDs, and probe IDs
Maps for both array platforms were generated.
```{r message=FALSE, warning=FALSE, results='hide'}
# Read array annotations

####################
# MAMC_DCI array annotations
####################
# Identify valid probes and retrieve their annotations.
# 
# Only probes remaining after initial processing will be considered.
# To determine which probes this encompasses, the processing steps to be 
# performed are performed and piped into the function AnnotationDbi::select as 
# the query.
hg2_probe_map <- oligo::rma( # Identify probes removed during normalization.
  raw_train, 
  background = TRUE,
  normalize = TRUE,
  target = "core"
) %>%
  affycoretools::getMainProbes() %>%
  Biobase::featureNames() %>% # Retrieve the feature names
  AnnotationDbi::select( # Retrieve annotation data.
  hugene20sttranscriptcluster.db,
  .,
  c( "ENSEMBL", "SYMBOL", "GENENAME" )
)

# Duplicated rows and rows for which values are missing were removed.
hg2_probe_map <- tidyr::drop_na(hg2_probe_map) %>%
  dplyr::filter(
    .,
    !duplicated(PROBEID)
  )

####################
# Horne_Lab array annotations
####################
# Define annotation file path.
annotation_file <- file.path("Data", "Arrays", "Horne_Lab", "A-AFFY-44", 
                             "A-AFFY-44.adf.txt")

u133_probe_file <- readr::read_tsv(
  annotation_file,
  skip = 20 # The first 20 lines are commented.
)

# Coerce horne_probe_file into the same format as dci_probe_map.
u133_probe_map <- dplyr::rename(
  u133_probe_file,
  PROBEID = "Composite Element Name",
  ENSEMBL = "Composite Element Database Entry[ensembl]"
) %>%
  dplyr::select(., PROBEID, ENSEMBL) %>%
  tidyr::drop_na() %>% # Drop probes without a corresponding gene.
  dplyr::filter(
    .,
    ENSEMBL %in% hg2_probe_map$ENSEMBL,
    !duplicated(PROBEID)
  )
```


Next, we filtered these maps such that they contained only probes matched to genes that were represented on both array types.
```{r message=FALSE, warning=FALSE, results='hide'}
# Identify genes represented on both array types.
valid_ensembl <- hg2_probe_map$ENSEMBL
valid_ensembl <- valid_ensembl[valid_ensembl %in% hg2_probe_map$ENSEMBL]
valid_ensembl <- valid_ensembl[valid_ensembl %in% u133_probe_map$ENSEMBL]
valid_ensembl <- sort(unique(valid_ensembl))

# Filter the probe maps such that only probes matched to the genes identified 
# above remain.
hg2_probe_map <- hg2_probe_map
u133_probe_map <- u133_probe_map[u133_probe_map$ENSEMBL %in% valid_ensembl,]

# Save the maps and vector of valid ENSEMBL IDs to the Cache.
source("Parameters.R")
saveRDS(hg2_probe_map, file = param$probe_map[["HuGene-2_0"]])
saveRDS(u133_probe_map, file = param$probe_map[["HG-U133_Plus_2"]])
saveRDS(valid_ensembl, file = param$valid_ensembl)
```


# Quality control and Normalization
## Filter probes
Finally, we filtered the background corrected array data to include only probes with matched ENSEMBL gene IDs in each data set.
```{r message=FALSE, warning=FALSE, results='hide'}
# Load annotations.
library(pd.hugene.2.0.st)

# Filter out probes that do not represent genes found on both arrays.
source(file.path("Scripts","FilterArray_functions.R"))

filt_train <- filter_arrays(
  raw_train, "MAMC_DCI__Train", normalize = FALSE
)
filt_test <- filter_arrays(
  raw_test, "MAMC_DCI__Test", normalize = FALSE
)
filt_testRepOfTrain <- filter_arrays(
  raw_testRepOfTrain, "MAMC_DCI__Test_RepOfTrain", normalize = FALSE
)
filt_horne <- filter_arrays(
  raw_horne, "Horne_Lab", normalize = FALSE
)
```


## Evaluation of gross expression levels
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=5}
tall_all_raw <- dplyr::bind_rows(
  tidyr::gather(filt_train, "Gene", "Expression", -Sample) %>%
    dplyr::mutate(Source = "Discovery"),
  tidyr::gather(filt_test, "Gene", "Expression", -Sample) %>%
    dplyr::mutate(Source = "Prospective"),
  tidyr::gather(filt_testRepOfTrain, "Gene", "Expression", -Sample) %>%
    dplyr::mutate(Source = "Replicated"),
  tidyr::gather(filt_horne, "Gene", "Expression", -Sample) %>%
    dplyr::mutate(Source = "Horne lab")
) %>%
  dplyr::mutate(
    GROUP = factor(Sample),
    Source = factor(
      Source, levels = c("Discovery","Prospective","Replicated","Horne lab"),
      labels = c("Discovery","Prospective","Replicated","External")
    )
  )

plt <- ggplot(
  tall_all_raw,
  aes(Expression, colour = Sample)
)+
  geom_density()+
  facet_wrap(~Source, nrow = 2, scales = "free")+
  theme(
    legend.position = "none",
    strip.background = element_blank(),
    plot.margin = margin(r = 1, t = 1, unit = "cm"),
    panel.spacing = unit(1, "lines")
  )+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_y_continuous(
    limits = c(0,0.5),
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    )
  )+
  scale_x_continuous(limits = c(0,15), breaks = seq(0,15,3))+
  xlab(bquote("log"[2]~("Expression")))+
  ylab("Probability Density")

# Save the plot.
cowplot::save_plot(
  file.path("Results","Raw_Expression_Density.tiff"),
  plt,
  base_width = 6.5, base_height = 5
)

# Display the plot.
plt
```


## Detect anomalous samples

### Perform PCA
```{r message=FALSE, warning=FALSE, results='hide'}
# Source the AnomalousSampleDetection_functions.R file.
source(file.path("Scripts", "AnomalousSampleDetection_functions.R"))

# Perform PCA.
pca_filt_train <- do_pca(
  "Array_filt_", "MAMC_DCI__Train", ref = TRUE
)
pca_filt_test <- do_pca(
  "Array_filt_", "MAMC_DCI__Test", ref = FALSE
)
pca_filt_testRepOfTrain <- do_pca(
  "Array_filt_", "MAMC_DCI__Test_RepOfTrain", ref = FALSE
)
pca_filt_horne <- do_pca(
  "Array_filt_", "Horne_Lab", ref = FALSE
)

# Stack the results.
pca_filt <- dplyr::bind_rows(
  pca_filt_train,
  pca_filt_test, pca_filt_testRepOfTrain
)

# Save the stacked results.
saveRDS(pca_filt, file.path("Cache", "Array_filt_pca.rds"))
```


### Plot PCA results
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Determine variation in each axis.
pca_df <- tibble::data_frame(
  var_percent = FactoMineR::PCA(
    dplyr::select(filt_train, -Sample),
    graph = FALSE
  )$eig[,"percentage of variance"],
  PC = paste(
    paste0("PC", 1:length(var_percent)),
    paste0("(", round(var_percent, 1), "%)")
  )
)
pca_filt_df <- dplyr::mutate(
  pca_filt,
  data_set = factor(
    data_set,
    levels = c(
      "MAMC_DCI__Train","MAMC_DCI__Test","MAMC_DCI__Test_RepOfTrain"
    ),
    labels = c("Discovery","Prospective","Replicated")
  ),
  Sample = gsub("MP", "PUL_", Sample),
  GROUP = factor(Sample)
) %>%
  dplyr::rename(Data = "data_set") %>%
  tibble::as_tibble()

# A scree plot was generated to visualize how variance explained changed by
# principal component.
plt <- ggplot(
  dplyr::mutate(pca_df, PC = 1:dplyr::n()),
  aes(PC, var_percent)
)+
  geom_point()+
  geom_line(colour = "red")+
  scale_y_continuous(
    limits = c(0,25),
    expand = c(0,0)
  )+
  scale_x_continuous(breaks = 1:16)+
  xlab("Principal Component")+ylab("Variance Explained (%)")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Scree_Plot_Unnormalized.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt

# Plot the projected points as a scatterplot.
plt <- ggplot(

)+
  geom_line(
    data = dplyr::filter(pca_filt_df, Sample %in% Sample[duplicated(Sample)]),
    mapping = aes(Dim.1, Dim.2, group = GROUP),
    colour = "black"
  )+
  geom_point(
    data = pca_filt_df,
    mapping = aes(Dim.1, Dim.2, colour = Data)
  )+
  xlab(pca_df$PC[1])+ylab(pca_df$PC[2])+
  geom_hline(yintercept = 0, colour = "gray", linetype = "dashed")+
  geom_vline(xintercept = 0, colour = "gray", linetype = "dashed")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))
  
# Save the plot.
cowplot::save_plot(
  file.path("Results", "PCA_Unnormalized_Data.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```

The differences between replicated samples and their discovery data set counterparts clearly show a systematic shift along PC1. This is undesirable. Thus, the prospective data set was normalized to the discovery data set using quantile normalization.


## Perform quantile normalization
```{r message=FALSE, warning=FALSE}
# Source the file QuantileNormalization_functions.R
source(file.path("Scripts", "QuantileNormalization_functions.R"))

# Perform quantile normalization on each data set.
norm_train <- quant_norm(
  reference = "MAMC_DCI__Train",
  target = "MAMC_DCI__Train"
)
norm_test <- quant_norm(
  reference = "MAMC_DCI__Train",
  target = "MAMC_DCI__Test"
)
norm_testRepOfTrain <- quant_norm(
  reference = "MAMC_DCI__Train",
  target = "MAMC_DCI__Test_RepOfTrain"
)
norm_horne <- quant_norm(
  reference = "MAMC_DCI__Train",
  target = "Horne_Lab"
)
```


## Evaluation of gross expression levels
```{r message=FALSE, warning=FALSE, fig.width=3.5, fig.height=7}
tall_all_raw <- dplyr::bind_rows(
  tidyr::gather(norm_train, "Gene", "Expression", -Sample) %>%
    dplyr::mutate(Source = "Discovery"),
  tidyr::gather(norm_test, "Gene", "Expression", -Sample) %>%
    dplyr::mutate(Source = "Prospective"),
  tidyr::gather(norm_testRepOfTrain, "Gene", "Expression", -Sample) %>%
    dplyr::mutate(Source = "Replicated")
) %>%
  dplyr::mutate(
    GROUP = factor(Sample),
    Source = factor(
      Source, levels = c("Discovery","Prospective","Replicated")
    )
  )

plt <- ggplot(
  tall_all_raw,
  aes(Expression, colour = Sample)
)+
  geom_density(colour = "black")+
  facet_wrap(~Source, nrow = 3, scales = "free")+
  theme(
    legend.position = "none",
    strip.background = element_blank(),
    plot.margin = margin(r = 1, t = 1, unit = "cm"),
    panel.spacing = unit(1, "lines")
  )+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_y_continuous(
    limits = c(0,0.5),
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    )
  )+
  scale_x_continuous(limits = c(0,15), breaks = seq(0,15,3))+
  xlab(bquote("log"[2]~("Expression")))+
  ylab("Probability Density")

# Save the plot.
cowplot::save_plot(
  file.path("Results","Normalized_Expression_Density.tiff"),
  plt,
  base_width = 3.5, base_height = 7
)

# Display the plot.
plt
```


## Detect anomalous samples

### Perform PCA
```{r message=FALSE, warning=FALSE, results='hide'}
# Source the AnomalousSampleDetection_functions.R file.
source(file.path("Scripts", "AnomalousSampleDetection_functions.R"))

# Perform PCA.
pca_norm_train <- do_pca(
  "Array_filt_norm_", "MAMC_DCI__Train", ref = TRUE
)
pca_norm_test <- do_pca(
  "Array_filt_norm_", "MAMC_DCI__Test", ref = FALSE
)
pca_norm_testRepOfTrain <- do_pca(
  "Array_filt_norm_", "MAMC_DCI__Test_RepOfTrain", ref = FALSE
)
pca_norm_horne <- do_pca(
  "Array_filt_norm_", "Horne_Lab", ref = FALSE
)

# Stack the results.
pca_norm <- dplyr::bind_rows(
  pca_norm_train,
  pca_norm_test, pca_norm_testRepOfTrain
)

# Save the stacked results.
saveRDS(pca_norm, file.path("Cache", "Array_filt_norm_pca.rds"))
```


### Plot PCA results
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Determine variation in each axis.
pca_df <- tibble::data_frame(
  var_percent = FactoMineR::PCA(
    dplyr::select(norm_train, -Sample),
    graph = FALSE
  )$eig[,"percentage of variance"],
  PC = paste(
    paste0("PC", 1:length(var_percent)),
    paste0("(", round(var_percent, 1), "%)")
  )
)
pca_filt_df <- dplyr::mutate(
  pca_norm,
  data_set = factor(
    data_set,
    levels = c(
      "MAMC_DCI__Train","MAMC_DCI__Test","MAMC_DCI__Test_RepOfTrain"
    ),
    labels = c("Discovery","Prospective","Replicated")
  ),
  Sample = gsub("MP", "PUL_", Sample),
  GROUP = factor(Sample)
) %>%
  dplyr::rename(Data = "data_set") %>%
  tibble::as_tibble()
plt <- ggplot(

)+
  geom_line(
    data = dplyr::filter(pca_filt_df, Sample %in% Sample[duplicated(Sample)]),
    mapping = aes(Dim.1, Dim.2, group = GROUP),
    colour = "black"
  )+
  geom_point(
    data = pca_filt_df,
    mapping = aes(Dim.1, Dim.2, colour = Data)
  )+
  xlab(pca_df$PC[1])+ylab(pca_df$PC[2])+
  geom_hline(yintercept = 0, colour = "gray", linetype = "dashed")+
  geom_vline(xintercept = 0, colour = "gray", linetype = "dashed")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))
  
# Save the plot.
cowplot::save_plot(
  file.path("Results", "PCA_Normalized_Data.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


This was also plotted interactively using plotly.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
if(doc_type == "html"){
  plot_ly(
    data = pca_norm,
    x = ~Dim.1, y = ~Dim.2, color = ~data_set, text = ~Sample
  )
}
```


Finally, the above was plotted without replicates included.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Determine variation in each axis.
pca_df <- tibble::data_frame(
  var_percent = FactoMineR::PCA(
    dplyr::select(norm_train, -Sample),
    graph = FALSE
  )$eig[,"percentage of variance"],
  PC = paste(
    paste0("PC", 1:length(var_percent)),
    paste0("(", round(var_percent, 1), "%)")
  )
)
pca_filt_df <- dplyr::filter(
  pca_norm,
  !data_set == "MAMC_DCI__Test_RepOfTrain"
) %>%
  dplyr::mutate(
    data_set = factor(
      data_set,
      levels = c(
        "MAMC_DCI__Train","MAMC_DCI__Test"
      ),
      labels = c("Discovery","Prospective")
    ),
    Sample = gsub("MP", "PUL_", Sample),
    GROUP = factor(Sample)
  ) %>%
  dplyr::rename(Data = "data_set") %>%
  tibble::as_tibble()
plt <- ggplot(

)+
  geom_point(
    data = pca_filt_df,
    mapping = aes(Dim.1, Dim.2, colour = Data)
  )+
  xlab(pca_df$PC[1])+ylab(pca_df$PC[2])+
  geom_hline(yintercept = 0, colour = "gray", linetype = "dashed")+
  geom_vline(xintercept = 0, colour = "gray", linetype = "dashed")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff"))
  
# Save the plot.
cowplot::save_plot(
  file.path("Results", "PCA_Normalized_Data_NoReplicates.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


A scree plot was generated to visualize how the variance explained changed by principal component.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
plt <- ggplot(
  dplyr::mutate(pca_df, PC = 1:dplyr::n()),
  aes(PC, var_percent)
)+
  geom_point()+
  geom_line(colour = "red")+
  scale_y_continuous(
    limits = c(0,25),
    expand = c(0,0)
  )+
  scale_x_continuous(breaks = 1:16)+
  xlab("Principal Component")+ylab("Variance Explained (%)")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Scree_Plot_Normalized.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```



# Predictive modeling
## Differential expression analysis
Differential expression analysis was performed as delineated in the script file indicated below. A number of cilia-related genes were identified as being differentially expressed. Of the differentially expressed genes, those described as being cilia-related in supplementary table 10 (https://doi.org/10.1371/journal.pone.0035618.s010) of the paper ["*Exploring the Transcriptome of Ciliated Cells Using In Silico Dissection of Human Tissues*" by Ivliev, Hoen, van Roon-Mom, Peters, and Sergeeva (https://doi.org/10.1371/journal.pone.0035618)](https://doi.org/10.1371/journal.pone.0035618) were retained for modeling using a K nearest neighbors model.


Differential expression analysis was performed and gene symbols for cilia-related genes were extracted for modeling.
```{r message=FALSE, warning=FALSE, results='hide'}
# Source the DE_for_KNN.R file to perform differential expression analysis.
source(file.path("Scripts","DE_for_KNN.R"))

# Load the gene symbols.
knn_gene_symbols <- readRDS(file.path("Cache","knn_genes_of_interest.rds"))
```


Gene ontology analysis was performed.
```{r message=FALSE, warning=FALSE}
# Load the DEGs.
degs <- readxl::read_excel(file.path("Results","TOP_DEA.xlsx"))
deg_ensembl <- unique(degs$ENSEMBL)
deg_ensembl <- deg_ensembl[!is.na(deg_ensembl)]
deg_entrez <- AnnotationDbi::mapIds(
  org.Hs.eg.db,
  keys = deg_ensembl,
  column = "ENTREZID",
  keytype = "ENSEMBL",
  multiVals = "first"
)
all_ensembl <- unique(hg2_probe_map$ENSEMBL)
all_ensembl <- all_ensembl[!is.na(all_ensembl)]
universe_entrez <- AnnotationDbi::mapIds(
  org.Hs.eg.db,
  keys = all_ensembl,
  column = "ENTREZID",
  keytype = "ENSEMBL",
  multiVals = "first"
)
go_results_bp <- clusterProfiler::enrichGO(
  gene = deg_entrez,
  universe = universe_entrez,
  OrgDb = "org.Hs.eg.db",
  keyType = "ENTREZID",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.1,
  qvalueCutoff = 0.1,
  minGSSize = 5,
  maxGSSize = 500
)
writexl::write_xlsx(
  as.data.frame(go_results_bp) %>% dplyr::filter(Count >= 5),
  file.path("Results","GO_Results_BP.xlsx")
)
go_results_cc <- clusterProfiler::enrichGO(
  gene = deg_entrez,
  universe = universe_entrez,
  OrgDb = "org.Hs.eg.db",
  keyType = "ENTREZID",
  ont = "CC",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.1,
  qvalueCutoff = 0.1,
  minGSSize = 5,
  maxGSSize = 500
)
writexl::write_xlsx(
  as.data.frame(go_results_cc) %>% dplyr::filter(Count >= 5),
  file.path("Results","GO_Results_CC.xlsx")
)
go_results_mf <- clusterProfiler::enrichGO(
  gene = deg_entrez,
  universe = universe_entrez,
  OrgDb = "org.Hs.eg.db",
  keyType = "ENTREZID",
  ont = "MF",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.1,
  qvalueCutoff = 0.1,
  minGSSize = 5,
  maxGSSize = 500
)
writexl::write_xlsx(
  as.data.frame(go_results_mf) %>% dplyr::filter(Count >= 5),
  file.path("Results","GO_Results_MF.xlsx")
)
```


After determining the genes of interest, the expression levels in each data set were normalized to match the distribution observed in the discovery set.
```{r message=FALSE, warning=FALSE, results='hide'}
# Load probe annotations.
probe_file <- read.csv(
  file.path(
    "Data", "Arrays", "MAMC_DCI", "Probeset_annotations",
    "HuGene-2_0-st-v1.na36.hg19.probeset.csv",
    "HuGene-2_0-st-v1.na36.hg19.probeset.csv"
  ),
  header = TRUE,
  comment.char = "#"
)

# Load differential expression data.
knn_de_results <- read.table(file.path(
  "Cache", "de_for_knn_top_genes.txt"
))

# Determine probe IDs of interest.
knn_valid_genes <- knn_de_results[knn_de_results$SYMBOL %in% knn_gene_symbols,]
knn_gene_symbols <- knn_valid_genes$SYMBOL
knn_genes_of_interest <- as.character(knn_valid_genes$ENSEMBL)
knn_probes_of_interest <- as.character(knn_valid_genes$PROBEID)

# Source the file QuantileNormalization_functions.R
source(file.path("Scripts", "QuantileNormalization_functions.R"))

# Perform quantile normalization on each data set.
knn_norm_train <- knn_quant_norm(
  reference = "MAMC_DCI__Train",
  target = "MAMC_DCI__Train",
  probe_file,
  ref_cache_prefix = "knn_all_",
  tar_cache_prefix = "Array_bg_"
)
knn_norm_test <- knn_quant_norm(
  reference = "MAMC_DCI__Train",
  target = "MAMC_DCI__Test",
  probe_file,
  ref_cache_prefix = "knn_all_",
  tar_cache_prefix = "Array_bg_"
)
knn_norm_testRepOfTrain <- knn_quant_norm(
  reference = "MAMC_DCI__Train",
  target = "MAMC_DCI__Test_RepOfTrain",
  probe_file,
  ref_cache_prefix = "knn_all_",
  tar_cache_prefix = "Array_bg_"
)
```


The datasets were reformatted to facilitate modeling.
```{r message=FALSE, warning=FALSE, results='hide'}
# Source the FormatDataForModeling_functions.R script.
source(file.path("Scripts", "FormatDataForModeling_functions.R"))

# Format the data for each data set.
knn_model_df_train <- format_data_for_model(
  cache_prefix = "knn_norm_",
  data_set = "MAMC_DCI__Train",
  knn_probes_of_interest
)
colnames(knn_model_df_train)[1:length(
  knn_probes_of_interest
)] <- knn_genes_of_interest
saveRDS(knn_model_df_train, file = file.path(
  "Cache", paste0("Model_values_", "knn_norm_", "MAMC_DCI__Train", ".rds")
))
knn_model_df_test <- format_data_for_model(
  cache_prefix = "knn_norm_",
  data_set = "MAMC_DCI__Test",
  knn_probes_of_interest
)
colnames(knn_model_df_test)[1:length(
  knn_probes_of_interest
)] <- knn_genes_of_interest
saveRDS(knn_model_df_test, file = file.path(
  "Cache", paste0("Model_values_", "knn_norm_", "MAMC_DCI__Test", ".rds")
))
knn_model_df_testRepOfTrain <- format_data_for_model(
  cache_prefix = "knn_norm_",
  data_set = "MAMC_DCI__Test_RepOfTrain",
  knn_probes_of_interest
)
colnames(knn_model_df_testRepOfTrain)[1:length(
  knn_probes_of_interest
)] <- knn_genes_of_interest
saveRDS(knn_model_df_testRepOfTrain, file = file.path(
  "Cache", 
  paste0("Model_values_", "knn_norm_", "MAMC_DCI__Test_RepOfTrain", ".rds")
))

# Remove from model_df_test all samples that are replicates of the training set.
knn_model_df_test <-  dplyr::filter(
    knn_model_df_test,
    !(Sample %in% knn_model_df_testRepOfTrain$Sample)
  )
saveRDS(knn_model_df_test, file = file.path(
  "Cache", paste0("Model_values_", "knn_norm_", "MAMC_DCI__Test", ".rds")
))

# Create a test PUL data set.
pul_sample_names <- (Biobase::pData(meta_test) %>%
  tibble::rownames_to_column(., "Sample") %>%
  dplyr::filter(., !is.na(PUL)))$Sample
knn_model_df_testPUL <- knn_model_df_test[
  knn_model_df_test$Sample %in% pul_sample_names,
]
saveRDS(knn_model_df_testPUL, file = file.path(
  "Cache", paste0("Model_values_", "knn_norm_", "MAMC_DCI__Test_PUL", ".rds")
))

# Create a test non-PUL data set.
sample_names <- (Biobase::pData(meta_test) %>%
  tibble::rownames_to_column(., "Sample") %>%
  dplyr::filter(., is.na(PUL)))$Sample
knn_model_df_testNonPUL <- knn_model_df_test[
  knn_model_df_test$Sample %in% sample_names,
]
saveRDS(knn_model_df_testNonPUL, file = file.path(
  "Cache", paste0("Model_values_", "knn_norm_", "MAMC_DCI__Test_NonPUL", ".rds")
))
```


### Perform PCA
```{r message=FALSE, warning=FALSE, results='hide'}
# Source the AnomalousSampleDetection_functions.R file.
source(file.path("Scripts", "AnomalousSampleDetection_functions.R"))

# Perform PCA.
knn_pca_filt_train <- do_pca(
  "Model_values_knn_norm_", "MAMC_DCI__Train", ref = TRUE
)
knn_pca_filt_test <- do_pca(
  "Model_values_knn_norm_", "MAMC_DCI__Test", ref = FALSE
)
knn_pca_filt_testRepOfTrain <- do_pca(
  "Model_values_knn_norm_", "MAMC_DCI__Test_RepOfTrain", ref = FALSE
)

# Stack the results.
knn_pca_filt <- dplyr::bind_rows(
  knn_pca_filt_train,
  knn_pca_filt_test, knn_pca_filt_testRepOfTrain
)

# Save the stacked results.
saveRDS(knn_pca_filt, file.path("Cache", "knn_norm_pca.rds"))
```


### Plot PCA results
The PCA results by data set with replicates linked by a solid line.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Determine variation in each axis.
pca_df <- tibble::data_frame(
  var_percent = FactoMineR::PCA(
    dplyr::select(knn_model_df_train, -Sample, -Location),
    graph = FALSE
  )$eig[,"percentage of variance"],
  PC = paste(
    paste0("PC", 1:length(var_percent)),
    paste0("(", round(var_percent, 1), "%)")
  )
)
pca_filt_df <- dplyr::mutate(
    dplyr::bind_rows(
      dplyr::mutate(knn_pca_filt_train, Location = knn_model_df_train$Location),
      dplyr::mutate(knn_pca_filt_test, Location = knn_model_df_test$Location),
      dplyr::mutate(
        knn_pca_filt_testRepOfTrain,
        Location = knn_model_df_testRepOfTrain$Location
      )
    ),
    data_set = factor(
      data_set,
      levels = c(
        "MAMC_DCI__Train","MAMC_DCI__Test","MAMC_DCI__Test_RepOfTrain"
      ),
      labels = c("Discovery","Prospective","Replicated")
    ),
    Sample = gsub("MP", "PUL_", Sample),
    GROUP = factor(Sample),
    Location = factor(Location, levels = c(0,1), labels = c("AIUP","ECT"))
  ) %>%
  dplyr::rename(Data = "data_set") %>%
  tibble::as_tibble()
plt <- ggplot(

)+
  geom_line(
    data = dplyr::filter(pca_filt_df, Sample %in% Sample[duplicated(Sample)]),
    mapping = aes(Dim.1, Dim.2, group = GROUP),
    colour = "black"
  )+
  geom_point(
    data = pca_filt_df,
    mapping = aes(Dim.1, Dim.2, colour = Data, shape = Location)
  )+
  xlab(pca_df$PC[1])+ylab(pca_df$PC[2])+
  geom_hline(yintercept = 0, colour = "gray", linetype = "dashed")+
  geom_vline(xintercept = 0, colour = "gray", linetype = "dashed")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))
  
# Save the plot.
cowplot::save_plot(
  file.path("Results", "PCA_Normalized_For_KNN_Replicates_Linked.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


The PCA results were also plotted without replicates linked.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Determine variation in each axis.
pca_df <- tibble::data_frame(
  var_percent = FactoMineR::PCA(
    dplyr::select(knn_model_df_train, -Sample, -Location),
    graph = FALSE
  )$eig[,"percentage of variance"],
  PC = paste(
    paste0("PC", 1:length(var_percent)),
    paste0("(", round(var_percent, 1), "%)")
  )
)
pca_filt_df <- dplyr::mutate(
    dplyr::bind_rows(
      dplyr::mutate(knn_pca_filt_train, Location = knn_model_df_train$Location),
      dplyr::mutate(knn_pca_filt_test, Location = knn_model_df_test$Location),
      dplyr::mutate(
        knn_pca_filt_testRepOfTrain,
        Location = knn_model_df_testRepOfTrain$Location
      )
    ),
    data_set = factor(
      data_set,
      levels = c(
        "MAMC_DCI__Train","MAMC_DCI__Test","MAMC_DCI__Test_RepOfTrain"
      ),
      labels = c("Discovery","Prospective","Replicated")
    ),
    Sample = gsub("MP", "PUL_", Sample),
    GROUP = factor(Sample),
    Location = factor(Location, levels = c(0,1), labels = c("AIUP","ECT"))
  ) %>%
  dplyr::rename(Data = "data_set") %>%
  tibble::as_tibble()
plt <- ggplot(

)+
  geom_point(
    data = pca_filt_df,
    mapping = aes(Dim.1, Dim.2, colour = Data, shape = Location)
  )+
  xlab(pca_df$PC[1])+ylab(pca_df$PC[2])+
  geom_hline(yintercept = 0, colour = "gray", linetype = "dashed")+
  geom_vline(xintercept = 0, colour = "gray", linetype = "dashed")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))
  
# Save the plot.
cowplot::save_plot(
  file.path("Results", "PCA_Normalized_For_KNN_Replicates_Unlinked.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


The results were also plotted without the inclusion of any replicates.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Determine variation in each axis.
train_pca <- FactoMineR::PCA(
    dplyr::select(knn_model_df_train, -Sample, -Location),
    graph = FALSE,
    ncp = 10
  )
pca_df <- tibble::data_frame(
  var_percent = train_pca$eig[,"percentage of variance"],
  PC = paste(
    paste0("PC", 1:length(var_percent)),
    paste0("(", round(var_percent, 1), "%)")
  )
)
pca_filt_df <- dplyr::mutate(
    dplyr::bind_rows(
      dplyr::mutate(knn_pca_filt_train, Location = knn_model_df_train$Location),
      dplyr::mutate(knn_pca_filt_test, Location = knn_model_df_test$Location)
    ),
    data_set = factor(
      data_set,
      levels = c(
        "MAMC_DCI__Train","MAMC_DCI__Test"
      ),
      labels = c("Discovery","Prospective")
    ),
    Sample = gsub("MP", "PUL_", Sample),
    GROUP = factor(Sample),
    Location = factor(Location, levels = c(0,1), labels = c("AIUP","ECT"))
  ) %>%
  dplyr::rename(Data = "data_set") %>%
  tibble::as_tibble()
plt <- ggplot(

)+
  geom_line(
    data = dplyr::filter(pca_filt_df, Sample %in% Sample[duplicated(Sample)]),
    mapping = aes(Dim.1, Dim.2, group = GROUP),
    colour = "black"
  )+
  geom_point(
    data = pca_filt_df,
    mapping = aes(Dim.1, Dim.2, colour = Data, shape = Location)
  )+
  xlab(pca_df$PC[1])+ylab(pca_df$PC[2])+
  geom_hline(yintercept = 0, colour = "gray", linetype = "dashed")+
  geom_vline(xintercept = 0, colour = "gray", linetype = "dashed")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff"))
  
# Save the plot.
cowplot::save_plot(
  file.path("Results", "PCA_Normalized_For_KNN_No_Replicates.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


A heatmap was generated to depict how each gene explained total variance across principal components.
```{r message=FALSE, warning=FALSE, fig.width=5.5, fig.height=4}
ensembl_to_symbol <- c(
  "ENSG00000124237" = "C20orf85",
  "ENSG00000141294" = "LRRC46",
  "ENSG00000165309" = "ARMC3",
  "ENSG00000174776" = "WDR49",
  
  "ENSG00000111834" = "RSPH4A",
  "ENSG00000133115" = "STOML3",
  "ENSG00000171517" = "LPAR3",
  "ENSG00000165164" = "CFAP47",
  
  "ENSG00000188931" = "CFAP126",
  "ENSG00000169064" = "ZBBX",
  "ENSG00000174844" = "DNAH12",
  "ENSG00000159713" = "TPPP3"
) %>%
  sort()

pca_df_plt_train <- train_pca$var$contrib %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Gene") %>%
  dplyr::mutate(
    Gene = ensembl_to_symbol[Gene]
  ) %>%
  tidyr::gather("PC", "Variance Explained (%)", -Gene) %>%
  dplyr::mutate(
    PC = gsub("Dim.","",PC)
  ) %>%
  dplyr::mutate(
    Gene = factor(Gene, levels = rev(sort(unique(Gene)))),
    PC = factor(
      PC, levels = 1:length(unique(PC)), labels = 1:length(unique(PC))
    )
  )
pcs <- sort(unique(pca_df_plt_train$PC))
for(i in 1:length(pcs)){
  pc_name <- pcs[i]
  pca_df_plt_train$`Variance Explained (%)`[
    pca_df_plt_train$PC == pc_name
  ] <- pca_df_plt_train$`Variance Explained (%)`[
    pca_df_plt_train$PC == pc_name]*train_pca$eig[
      paste0("comp ", i),"percentage of variance"
    ]/100
}

# Plot the variance explained as a heatmap.
plt <- ggplot(
  pca_df_plt_train,
  aes(PC, Gene, fill = `Variance Explained (%)`)
)+
  geom_tile(colour = "black")+
  scale_fill_continuous(low = "white", high = "red", limits = c(0,10))+
  scale_x_discrete(position = "top", expand = c(0,0))+
  scale_y_discrete(expand = c(0,0))+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  labs(fill = "Variance\nExplained (%)")+
  theme(
    axis.title.y = element_blank()
  )+
  xlab("Principal Component")

# Save the plot.
cowplot::save_plot(
  file.path("Results","Discovery_PCA_Variance_Heatmap.tiff"),
  plt,
  base_width = 5.5, base_height = 4
)

# Display the plot.
plt
```


A scree plot was generated from the above PCA analysis.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
pca_df <- train_pca$eig[,"percentage of variance", drop = FALSE] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("PC") %>%
  dplyr::mutate(
      PC = gsub("comp ","",PC)
  ) %>%
  dplyr::mutate(PC = factor(PC, levels = 1:length(PC))) %>%
  dplyr::rename(var_percent = "percentage of variance")

plt <- ggplot(
  dplyr::mutate(pca_df, PC = 1:dplyr::n()),
  aes(PC, var_percent)
)+
  geom_point()+
  geom_line(colour = "red")+
  scale_y_continuous(
    limits = c(0,100),
    expand = c(0,0)
  )+
  scale_x_continuous(breaks = 1:16)+
  xlab("Principal Component")+ylab("Variance Explained (%)")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Scree_Plot_Normalized_KNN.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


### Create a KNN model from expression levels


Although the PCA plots above reveal that pregnancy location is completely separable in the discovery data using a linear model, the small sample sizes put such a model at very high risk of overfitting. Thus, a KNN model, which should be more robust to outliers was used. A KNN model (k ranging from 1 to 6) was generated and evaluated on the training data when 0 to 4 samples were excluded. This exclusion was performed in order to evaluate model stability.


```{r message=FALSE, warning=FALSE, results='hide'}
# Specify modeling parameters.
seeds <- 1:200
k_range <- 1:6
samples_ignored <- 0:4

# Create a data.frame where each row contains the modeling parameters for a 
# single iteration of the model.
runs <- expand.grid(seeds, k_range, samples_ignored) %>%
  dplyr::rename(
    .,
    seed = "Var1", k = "Var2", samples_ignored = "Var3"
  ) %>%
  dplyr::mutate(
    .,
    Run = 1:dplyr::n(),
    Accuracy = NA
  )
runs[,paste0("SampleIgnored_",samples_ignored)] <- NA

# Save the data with gene information.
writexl::write_xlsx(
  dplyr::mutate(knn_model_df_train, Location = c("AIUP","ECT")[Location+1]),
  file.path("Results","knn_model_data_discovery.xlsx")
)
writexl::write_xlsx(
  dplyr::mutate(knn_model_df_test, Location = c("AIUP","ECT")[Location+1]),
  file.path("Results","knn_model_data_prospective.xlsx")
)

# Save the data to the disk so that it can be easily retrieved when working in 
# parallel.
knn_model_df_train <- dplyr::bind_cols(
  knn_model_df_train[,c("Sample","Location")],
  knn_pca_filt_train[,c("Dim.1","Dim.2")]
)
saveRDS(knn_model_df_train, file.path("Cache", "KNN_.rds"))
saveRDS(
  knn_model_df_train,
  file.path(
    "Cache", file = paste0("Model_values_knn_norm_", "MAMC_DCI__Train", ".rds")
  )
)
knn_model_df_test <- dplyr::bind_cols(
  knn_model_df_test[,c("Sample","Location")],
  knn_pca_filt_test[,c("Dim.1","Dim.2")]
)
saveRDS(
  knn_model_df_test,
  file = file.path(
    "Cache", paste0("Model_values_knn_norm_", "MAMC_DCI__Test", ".rds")
  )
)

saveRDS(
  knn_model_df_test[knn_model_df_test$Sample %in% pul_sample_names,],
  file = file.path(
    "Cache", paste0("Model_values_knn_norm_", "MAMC_DCI__Test_PUL", ".rds")
  )
)
saveRDS(
  knn_model_df_test[knn_model_df_test$Sample %in% sample_names,],
  file = file.path(
    "Cache", paste0("Model_values_knn_norm_", "MAMC_DCI__Test_nonPUL", ".rds")
  )
)

# Iterate through each parameter set.
num_cores <- parallel::detectCores()
modeling_results <- parallel::parLapply(
  parallel::makeCluster(num_cores),
  split(runs, 1:nrow(runs)),
  function(df){
    # Define parameters.
    num_folds <- 10
    
    # Set the random seed.
    set.seed(df$seed)
    
    # Retrieve parameters.
    k <- df$k
    num_samples_ignored <- df$samples_ignored
    
    # Load the data from the disk.
    modeling_df <- readRDS(file.path("Cache", "KNN_.rds"))
    modeling_location <- modeling_df$Location
    modeling_samples <- modeling_df$Sample
    modeling_df <- modeling_df[
      ,
      !(colnames(modeling_df) %in% c("Sample","Location"))
    ]
    rownames(modeling_df) <- modeling_samples
    
    # Identify samples to retain for training.
    samples_to_remove <- sort(sample(
      1:nrow(modeling_df), 
      num_samples_ignored
    ))
    samples_to_keep <- (1:nrow(modeling_df))[-samples_to_remove]
    
    # Handle the case in which there are no samples to remove.
    if(length(samples_to_keep) == 0){
      samples_to_keep <- 1:nrow(modeling_df)
    }
    
    # Add to df the names of the samples removed.
    if(length(samples_to_remove) != 0){
      sample_names <- rownames(modeling_df)[samples_to_remove]
      
      df[1,paste0(
        "SampleIgnored_",
        1:df$samples_ignored
      )] <- sample_names
    }
    
    # Subset the data given the samples removed.
    c_dat <- modeling_df[samples_to_keep,]
    loc_dat <- modeling_location[samples_to_keep]
    
    # Load the "class" and caret packages.
    library(class)
    
    # Train the sample on different folds.
    folds <- caret::createFolds(loc_dat, k = num_folds)
    accuracies <- sapply(
      seq_along(folds),
      function(i){
        # Determine training and testing indices.
        train_indices <- (1:nrow(c_dat))[-folds[[i]]]
        test_indices <- folds[[i]]
        
        # Train and predict.
        predictions <- class::knn(
          train = c_dat[train_indices,],
          test = c_dat[test_indices,],
          cl = loc_dat[train_indices],
          k = k
        )
        
        # Calculate the accuracy.
        accuracy <- mean(loc_dat[test_indices] == predictions)
        
        # Return the accuracy
        return(accuracy)
      }
    )
    
    # Append the accuracies to df as new columns. Handle missing values.
    accuracies_temp <- rep(NA, num_folds)
    accuracies_temp[1:length(accuracies)] <- accuracies
    accuracies <- accuracies_temp
    accuracies <- as.data.frame(matrix(accuracies, nrow = 1))
    names(accuracies) <- paste0("Accuracy_", 1:num_folds)
    output_df <- dplyr::bind_cols(
      df,
      accuracies
    )
    
    # Return the output.
    return(output_df)
  }
) %>%
  dplyr::bind_rows()
```


Modeling results were rearranged and their accuracies summarized on a per run basis to evaluate how parameters affect model accuracy.
```{r message=FALSE, warning=FALSE, results='hide'}
# Arrange the data in a tidy format.
tall_modeling_results <- modeling_results[
  ,
  !(colnames(modeling_results) %in% 
      c("Accuracy",paste0("SampleIgnored_",1:max(samples_ignored))))
] %>%
  tidyr::gather(
    .,
    key = Fold,
    value = Accuracy,
    -seed, -k, -samples_ignored, -Run
  ) %>%
  tidyr::drop_na()

# Summarize by run.
modeling_results_by_run <- modeling_results[
  ,
  !(colnames(modeling_results) %in% 
      c("Accuracy",paste0("SampleIgnored_",0:ncol(modeling_results))))
]
modeling_results_by_run$Accuracy <- rowMeans(
  modeling_results_by_run[
    colnames(modeling_results_by_run) %in% 
      paste0("Accuracy_",1:ncol(modeling_results_by_run))
  ],
  na.rm = TRUE
)
modeling_results_by_run <- modeling_results_by_run[
  ,
  !(colnames(modeling_results_by_run) %in% 
      paste0("Accuracy_",0:ncol(modeling_results_by_run)))
] %>%
  dplyr::mutate(
    .,
    Accuracy = Accuracy * 100
  )
```


The accuracies for each run were plotted as a histogram. The red line indicates the accuracy of the naive model (always predicting the most abundant class).
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=6.5}
# Create a histogram.
plot_simple_accuracy <- ggplot(
  dplyr::mutate(
    modeling_results_by_run,
    SR = factor(
      samples_ignored, levels = (sort(unique(samples_ignored)))
    )
  ),
  aes(Accuracy)
)+
  geom_histogram(binwidth = 5, aes(y = ..density..))+
  xlab("Accuracy (%)")+ylab("Count")+
  coord_cartesian(xlim = c(0,100), ylim = c(0, 2500), expand = FALSE)+
  theme(
    plot.margin = margin(r = 1, t = 1, l = 1, unit = "cm"),
    strip.background = element_blank(),
    panel.spacing = unit(0.75, "lines"),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    axis.text = element_text(size = 10),
  )+
  scale_x_continuous(
    limits = c(0,110),
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    ),
    breaks = seq(0,100,50)
  )+
  scale_y_continuous(
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    ),
    breaks = seq(0,0.15,0.05),
    position = "right"
  )+
  coord_cartesian(xlim = c(0,100), ylim = c(0,0.15))+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  facet_grid(
    SR~k, scales = "fixed", switch = "y",
    labeller = label_both
  )+
  ylab("Probability Density")

# Display the plot.
plot_simple_accuracy

# Save the plot.
cowplot::save_plot(
  file.path("Results","knn_training_accuracy_many_models.tiff"),
  plot_simple_accuracy,
  base_width = 6.5, base_height = 6.5
)
```


Accuracy was also plotted in 3D in an interactive manner.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=6.5}
# Plot the accuracy in parameter space.
if(doc_type != "pdf"){
  plot_parameters_accuracy <- plot_ly(
    data = modeling_results_by_run,
    x = ~samples_ignored, y = ~k, z = ~Accuracy,
    text = ~Run,
    mode = "markers+scatter3d",
    color = ~Accuracy, colors = c("blue", "green"),
    marker = list(
      size = 4
    )
  ) %>%
    layout(
      scene = list(
        xaxis = list(title = "Samples ignored"),
        yaxis = list(title = "K"),
        zaxis = list(title = "Average Accuracy", range = c(0,100)),
        aspectmode = "manual",
        aspectratio = list(
          x = 2, y = 2, z = 1
        )
      )
    )
}


# Save the plot.
output_file <- "parameters_knn_accuracy_train_by_run.html"
if(is.null(doc_type) || (doc_type == "html")){
  htmlwidgets::saveWidget(
    plot_parameters_accuracy, 
    output_file
  )
  invisible(
    {
      file.copy(output_file, file.path("Results",output_file), overwrite = TRUE)
      file.remove(output_file)
    }
  )
}
```


The accuracies were also plotted in parameter space (only viewable as HTML).
```{r message=FALSE, warning=FALSE}
if(doc_type == "html"){
  plot_parameters_accuracy
}
```


The average accuracies for each parameter combination were also plotted in parameter space (only viewable as HTML).
```{r message=FALSE, warning=FALSE, fig.width=9.5, fig.height=6.5}
# Summarize the results.
summarized_results <- dplyr::group_by(
  modeling_results_by_run,
  k, samples_ignored
) %>%
  dplyr::summarise(
    Mean_Accuracy = mean(Accuracy)
  ) %>%
  dplyr::ungroup()

# Plot the summarized results.
new_k <- sort(unique(summarized_results$k))
new_samples_ignored <- sort(unique(summarized_results$samples_ignored))

vals_grid <- matrix(nrow = length(new_k), ncol = length(new_samples_ignored))
spots <- summarized_results[,c("k","samples_ignored")]
spots[,"samples_ignored"] <- spots[,"samples_ignored"] + 1
vals_grid[as.matrix(
  spots
)] <- summarized_results$Mean_Accuracy
labels_grid <- vals_grid
labels_grid[as.matrix(as.matrix(
  spots
))] <- paste0(
  "</br>Ignored: ", summarized_results$samples_ignored," ",
  "</br>K: ", summarized_results$k," ",
  "</br>Accuracy: ", round(summarized_results$Mean_Accuracy, 1), "%"
)

plot_summarized_parameters_accuracy <- plot_ly(data = summarized_results) %>%
  add_surface(
    x = ~new_samples_ignored, y = ~new_k, z = ~vals_grid,
    colorbar = list(title = "Average Accuracy"),
    hoverinfo = "text",
    text = labels_grid
  ) %>%
  layout(
    scene = list(
      xaxis = list(title = "Samples ignored"),
      yaxis = list(title = "K"),
      zaxis = list(title = "Average Accuracy", range = c(0,100)),
      aspectmode = "manual",
      aspectratio = list(
        x = 2, y = 2, z = 1
      )
    )
  )

# Save the plot.
output_file <- "parameters_knn_accuracy_train_summarized.html"
if(is.null(doc_type) || (doc_type == "html")){
  htmlwidgets::saveWidget(
    plot_summarized_parameters_accuracy, 
    output_file
  )
  invisible(
    {
      file.copy(output_file, file.path("Results",output_file), overwrite = TRUE)
      file.remove(output_file)
    }
  )
}

# Display the plot.
if(doc_type == "html"){
  plot_summarized_parameters_accuracy
}
```


```{r message=FALSE, warning=FALSE, fig.width=5.5, fig.height=5.5}
# Summarize the results.
summarized_results <- dplyr::group_by(
  modeling_results_by_run,
  k, samples_ignored
) %>%
  dplyr::summarise(
    Mean_Accuracy = mean(Accuracy),
    SD_Accuracy = sd(Accuracy),
    N = dplyr::n(),
    SE = SD_Accuracy/sqrt(N-1)
  ) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(
    k = factor(k),
    samples_ignored = factor(
      samples_ignored,
      levels = (0:max(samples_ignored)),
      labels = (0:max(samples_ignored))
    )
  )

# Plot the variance explained as a heatmap.
plt <- ggplot(
  summarized_results,
  aes(k, samples_ignored, fill = Mean_Accuracy)
)+
  geom_tile(colour = "black")+
  scale_fill_continuous(low = "white", high = "red", limits = c(80,100))+
  scale_x_discrete(expand = c(0,0))+
  scale_y_discrete(expand = c(0,0))+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  labs(fill = "Variance\nExplained (%)")+
  ylab("Samples Ignored")+
  xlab("k")

# Save the plot.
cowplot::save_plot(
  file.path("Results","Discovery_Accuracy_Heatmap.tiff"),
  plt,
  base_width = 5.5, base_height = 3.5
)

# Display the plot.
plt
```


A function was created to generate and parse knn predictions. This was used to iteratively evaluate knn models using different values of k.
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
knn_predictor <- function(
  reference,
  target,
  k,
  same = FALSE
){
  set.seed(123456789)
  reference$Location <- c(
    "0" = "AIUP", "1" = "Ectopic"
  )[as.character(reference$Location)]
  target$Location <- c(
    "0" = "AIUP", "1" = "Ectopic"
  )[as.character(target$Location)]
  
  # Make predictions
  num_resamples <- 100
  train_frac <- 0.7
  if(same){
    out <- lapply(
      1:num_resamples,
      function(ITERATION){
        inner_ref <- reference
        train_ind <- c(
          sample(
            which(inner_ref$Location == "AIUP"), 
            train_frac*sum(inner_ref$Location == "AIUP"), 
            replace = FALSE
          ),
          sample(
            which(inner_ref$Location == "Ectopic"), 
            train_frac*sum(inner_ref$Location == "Ectopic"), 
            replace = FALSE
          )
        )
        test_ind <- (1:nrow(inner_ref))[!((1:nrow(inner_ref)) %in% train_ind)]
        predictions <- class::knn(
          train = inner_ref[train_ind,grepl("^Dim.", colnames(inner_ref))],
          test = target[test_ind,grepl("^Dim.", colnames(inner_ref))],
          cl = inner_ref$Location[train_ind],
          k = k,
          prob = TRUE
        )
        
        # Determine the probability of an ectopic.
        prob <- attr(predictions, "prob")
        predictions[prob == 0.5] <- "AIUP" # Default prediction is AIUP.
        pred_num <- as.numeric(predictions == "Ectopic")
        prob[pred_num == 0] <- 1 - prob[pred_num == 0]

        # Create the output object.
        out <- dplyr::select(
          target[test_ind,],
          Sample, Location
        ) %>%
          dplyr::mutate(
            .,
            Prediction = predictions,
            Ectopic_Probability = prob,
            Prediction_Numeric = pred_num,
            Class_Numeric = as.numeric(Location == "Ectopic"),
            Prediction_Correct = Location == as.character(Prediction),
            Iteration = ITERATION
          )
        
        if("initially_pul" %in% colnames(inner_ref)){
          out[,"initially_pul"] <- inner_ref$initially_pul[test_ind]
        }
        
        return(out)
      }
    ) %>%
    dplyr::bind_rows()
  }else{
    out <- lapply(
      1:num_resamples,
      function(ITERATION){
        inner_ref <- reference
        train_ind <- c(
          sample(
            which(inner_ref$Location == "AIUP"), 
            train_frac*sum(inner_ref$Location == "AIUP"), 
            replace = FALSE
          ),
          sample(
            which(inner_ref$Location == "Ectopic"), 
            train_frac*sum(inner_ref$Location == "Ectopic"), 
            replace = FALSE
          )
        )
        predictions <- class::knn(
          train = inner_ref[train_ind,grepl("^Dim.", colnames(inner_ref))],
          test = target[,grepl("^Dim.", colnames(inner_ref))],
          cl = inner_ref$Location[train_ind],
          k = k,
          prob = TRUE
        )
        
        # Determine the probability of an ectopic.
        prob <- attr(predictions, "prob")
        predictions[prob == 0.5] <- "Ectopic" # Default prediction is Ectopic.
        pred_num <- as.numeric(predictions == "Ectopic")
        prob[pred_num == 0] <- 1 - prob[pred_num == 0]
  
        # Create the output object.
        out <- dplyr::select(
          target,
          Sample, Location
        ) %>%
          dplyr::mutate(
            .,
            Prediction = predictions,
            Ectopic_Probability = prob,
            Prediction_Numeric = pred_num,
            Class_Numeric = as.numeric(Location == "Ectopic"),
            Prediction_Correct = Location == as.character(Prediction),
            Iteration = ITERATION
          )
        
        if("initially_pul" %in% colnames(inner_ref)){
          out[,"initially_pul"] <- target$initially_pul
        }
        
        return(out)
      }
    ) %>%
      dplyr::bind_rows()
  }
  
  
  pvalue_getter <- function(x){
    if(length(x) == 1){
      return(x)
    }else{
      return(mean(x >= 0.5))
    }
  }

  out <- dplyr::group_by(out, Sample, Location) %>%
    dplyr::summarise(
        .,
        Ectopic_Probability = pvalue_getter(Ectopic_Probability)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      .,
      Prediction = ifelse(Ectopic_Probability >= 0.5, "Ectopic", "AIUP"),
      Prediction_Numeric = as.numeric(Ectopic_Probability >= 0.5),
      Class_Numeric = as.numeric(Location == "Ectopic"),
      Prediction_Correct = Location == Prediction
    )
  
  

  return(out)
}

# Evaluate different values of k.
max_accuracy <- 0
best_i <- 1
discovery_model_selection <- tibble::data_frame()
for(i in best_i:8){
  preds_train <- knn_predictor(
    knn_model_df_train[,c(c("Dim.1","Dim.2"),"Location","Sample")],
    knn_model_df_train[,c(c("Dim.1","Dim.2"),"Location","Sample")],
    k = i,
    same = TRUE
  )
  accuracy <- mean(preds_train$Prediction_Correct)
  if(accuracy > max_accuracy){
    max_accuracy <- accuracy
    best_i <- i
  }
  discovery_model_selection <- dplyr::bind_rows(
    discovery_model_selection,
    tibble::data_frame(
      `k` = i,
      Accuracy = 100*accuracy,
      N = nrow(knn_model_df_train)
    )
  )
}
discovery_model_selection <- dplyr::mutate(
  discovery_model_selection,
  k = factor(k)
)

plt <- ggplot(
  discovery_model_selection,
  aes(k, Accuracy, group = 1)
)+
  geom_point()+
  geom_line(colour = "red")+
  scale_y_continuous(
    limits = c(0,1000),
    expand = expand_scale(mult = c(0,0), add= c(0,0)),
    breaks = seq(0,100,25)
  )+
  ylab("Accuracy (%)")+
  coord_cartesian(ylim = c(0,100))+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)

# Save the plot.
cowplot::save_plot(
  file.path("Results","Discovery_k_selection_accuracy.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Display the plot.
plt
```


Based on the above results, k = 3 was selected as the optimum k for modeling. This was justified based on the observation that while all k > 2 had approximately the same performance on the discovery data, k = 3 was the smallest k for which accuracy was high. Selecting a larger k would risk overfitting. In addition, accuracy was stable even when the model was evaluated on the discovery data when samples were excluded.


#### Make predictions
```{r message=FALSE, warning=FALSE, results='hide'}
# Source the file MakePredictions_functions.R
source(file.path("Scripts", "MakePredictions_functions.R"))

# Make the predictions
knn_predictions_train <- make_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Train",
  cache_prefix = "Model_values_knn_norm_"
)
knn_predictions_test <- make_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Test",
  cache_prefix = "Model_values_knn_norm_"
)
knn_predictions_testPUL <- make_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Test_PUL",
  cache_prefix = "Model_values_knn_norm_"
)
knn_predictions_testNonPUL <- make_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Test_nonPUL",
  cache_prefix = "Model_values_knn_norm_"
)
```


The predictions made on the discovery data were evaluated.
```{r message=FALSE, warning=FALSE}
caret::confusionMatrix(
  factor(knn_predictions_train$Prediction, levels = c(0,1)), 
  factor(knn_predictions_train$Location, levels = c(0,1))
)
```


An ROC curve was also created for the discovery data.
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
# Generate the ROC curve.
roc_train <- make_roc(knn_predictions_train)
knn_predictions_train_roc <- knn_predictions_train

# Save the ROC curve.
cowplot::save_plot(
  file.path("Results", "ROC_Train.tiff"),
  roc_train$plt,
  base_width = 4, base_height = 4
)

# Plot the ROC curve.
roc_train$plt

# Print the AUC.
print(paste0("AUC = ", round(roc_train$auc,2)))
```


The predictions made on the prospective data were also evaluated.
```{r message=FALSE, warning=FALSE}
caret::confusionMatrix(
  factor(knn_predictions_test$Prediction, levels = c(0,1)), 
  factor(knn_predictions_test$Location, levels = c(0,1))
)
```


Plot the corresponding ROC curve
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
# Generate the ROC curve.
roc_test <- make_roc(knn_predictions_test)
knn_predictions_test_roc <- knn_predictions_test

# Save the ROC curve.
cowplot::save_plot(
  file.path("Results", "ROC_Test.tiff"),
  roc_test$plt,
  base_width = 4, base_height = 4
)

# Plot the ROC curve.
roc_test$plt

# Print the AUC.
print(paste0("AUC = ", round(roc_test$auc,2)))
```


The model was evaluated specifically on the non-PUL samples.
```{r message=FALSE, warning=FALSE}
caret::confusionMatrix(
  factor(knn_predictions_testNonPUL$Prediction, levels = c(0,1)), 
  factor(knn_predictions_testNonPUL$Location, levels = c(0,1))
)
```


The corresponding ROC curve was also plotted.
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
# Generate the ROC curve.
roc_testNonPUL <- make_roc(knn_predictions_testNonPUL)

# Save the ROC curve.
cowplot::save_plot(
  file.path("Results","ROC_NonPUL.tiff"),
  roc_testNonPUL$plt,
  base_width = 4, base_height = 4
)

# Plot the ROC curve.
roc_testNonPUL$plt

# Print the AUC.
print(paste0("AUC = ", round(roc_testNonPUL$auc,2)))
```


The model was evaluated specifically on the PUL samples. Since all of these samples belong to the same class (ECT), an ROC cannot be generated for this subset of the data.
```{r message=FALSE, warning=FALSE}
caret::confusionMatrix(
  factor(knn_predictions_testPUL$Prediction, levels = c(0,1)), 
  factor(knn_predictions_testPUL$Location, levels = c(0,1))
)
```


#### Make predictions on bootstrapped samples


The model was evaluated on bootstrapped samples of the above datasets.


```{r message=FALSE, warning=FALSE, results='hide'}
# Source the file MakePredictions_functions.R
source(file.path("Scripts", "MakePredictions_functions.R"))

# Define the number of resamplings to perform.
num_samples <- 10000

# Make the predictions
knn_predictions_train <- make_bootstrap_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Train",
  num_samples = num_samples,
  cache_prefix = "Model_values_knn_norm_"
)
knn_predictions_test <- make_bootstrap_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Test",
  num_samples = num_samples,
  cache_prefix = "Model_values_knn_norm_"
)
knn_predictions_testPUL <- make_bootstrap_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Test_PUL",
  num_samples = num_samples,
  cache_prefix = "Model_values_knn_norm_"
)
knn_predictions_testNonPUL <- make_bootstrap_predictions(
  model = "KNN_",
  data_set = "MAMC_DCI__Test_nonPUL",
  num_samples = num_samples,
  cache_prefix = "Model_values_knn_norm_"
)
```


#### Plot the accuracies
```{r message=FALSE, warning=FALSE, results='hide', fig.width=6.5, fig.height=6.5}
# Source the file PlotAccuracies_functions.R
source(file.path("Scripts", "PlotAccuracies_functions.R"))

# Generate the plots.
knn_bs_analysis_train <- plot_bootstrap_accuracies(
  "KNN_",
  "MAMC_DCI__Train",
  display_reference = TRUE,
  reference = "MAMC_DCI__Train",
  base_prefix = "Model_values_knn_norm_"
)
knn_bs_analysis_test <- plot_bootstrap_accuracies(
  "KNN_",
  "MAMC_DCI__Test",
  display_reference = FALSE,
  reference = "MAMC_DCI__Train",
  base_prefix = "Model_values_knn_norm_"
)
knn_bs_analysis_testPUL <- plot_bootstrap_accuracies(
  "KNN_",
  "MAMC_DCI__Test_PUL",
  display_reference = FALSE,
  reference = "MAMC_DCI__Train",
  base_prefix = "Model_values_knn_norm_"
)
knn_bs_analysis_testNonPUL <- plot_bootstrap_accuracies(
  "KNN_",
  "MAMC_DCI__Test_nonPUL",
  display_reference = FALSE,
  reference = "MAMC_DCI__Train",
  base_prefix = "Model_values_knn_norm_"
)

# Create a paneled plot.
plt <- cowplot::plot_grid(
  knn_bs_analysis_train$figure+ggtitle("Discovery"),
  knn_bs_analysis_test$figure+ggtitle("Prospective"),
  knn_bs_analysis_testNonPUL$figure+ggtitle("Prospective - Non-PUL"),
  knn_bs_analysis_testPUL$figure+ggtitle("Prospective - PUL"),
  ncol = 2
)

# Save the plot.
cowplot::save_plot(
  file.path("Results","Accuracies_KNN_Bootstrap.tiff"),
  plt,
  base_width = 6.5, base_height = 5
)

# Display the plot.
plt
```


The prediction accuracies were summarized.
```{r message=FALSE, warning=FALSE}
# Summarize the prediction accuracies.
knn_prediction_results <- dplyr::bind_cols(
  knn_bs_analysis_train$output, 
  knn_bs_analysis_test$output["Value"], 
  knn_bs_analysis_testPUL$output["Value"], 
  knn_bs_analysis_testNonPUL$output["Value"]
) %>%
  tibble::column_to_rownames(., "Variable") %>%
  as.matrix() %>%
  t() %>%
  as.data.frame() %>%
  tibble::as_tibble() %>%
  dplyr::select(., -model, -reference, -naive_ref_accuracy)
knn_prediction_results$p_val <- as.numeric(
  as.character(knn_prediction_results$p_val)
)
knn_prediction_results$N <- as.integer(
  as.character(knn_prediction_results$N)
)
knn_prediction_results$Mean_Accuracy <- as.numeric(
  as.character(knn_prediction_results$Mean_Accuracy)
)
knn_prediction_results$Median_Accuracy <- as.numeric(
  as.character(knn_prediction_results$Median_Accuracy)
)
rownames(knn_prediction_results) <- NULL
colnames(knn_prediction_results) <- c(
  "Data set", "P value", "N", "Mean accuracy", "Median accuracy"
)

# Drop NAs.
knn_prediction_results <- tidyr::drop_na(knn_prediction_results) %>%
  as.data.frame()

# Save the knn_prediction_results.
writexl::write_xlsx(
  knn_prediction_results,
  file.path("Results", "knn_prediction_results.xlsx")
)

# Display the prediction results.
if(is.null(doc_type) || (doc_type == "html")){
  knitr::kable(knn_prediction_results, digits = 2) %>%
    kableExtra::kable_styling(bootstrap_options = "striped")
}else{
  pander::pander(as.data.frame(knn_prediction_results))
}
```


Predictions without bootstrapping were saved.
```{r message=FALSE, warning=FALSE}
# Determine the naive model class estimate.
naive_class <- table(knn_model_df_train$Location) %>%
  sort() %>%
  tail(1) %>%
  names()

# Make predictions.
set.seed(123456789)
k <- 3
preds_train <- knn_predictor(
  knn_model_df_train, knn_model_df_train,
  k = k, same = TRUE
)
preds_test <- knn_predictor(
  knn_model_df_train, knn_model_df_test,
  k = k, same = FALSE
)
writexl::write_xlsx(knn_model_df_train, file.path("Results","Train_Norm.xlsx"))
writexl::write_xlsx(knn_model_df_test, file.path("Results","Test_Norm.xlsx"))
writexl::write_xlsx(preds_train, file.path("Results","KNN_preds_train.xlsx"))
writexl::write_xlsx(preds_test, file.path("Results","KNN_preds_test.xlsx"))
```


Predictions were also made on the Horne lab data. Since the Horne lab data was from a different platform, a separate KNN model was fit on the Horne data. Because some of the genes used in the model above were not represented on the array used by the Horne lab, only the genes that overlapped between the two arrays were used. A 70:30 split was used to partition the Horne lab data into training and testing sets. The optimum value of k was selected by determining the k that resulted in the highest accuracy on the training set. During the k selection process, model accuracy was evaluated on 70:30 splits of the training data after random sampling (100 repeats).
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Do a a 70:30 split.
# Filter the Horne lab data.
filt_horne_f <- filt_horne[!grepl("1-", filt_horne$Sample),]
meta_horne_f <- meta_horne[!grepl("1-", Biobase::sampleNames(meta_horne)),]
set.seed(1234567)
frac_train <- 0.7
horne_train_indices <- c(
  sample(
    which(meta_horne_f@data$Group == "EP"),
    frac_train*length(which(meta_horne_f@data$Group == "EP"))
  ),
  sample(
    which(meta_horne_f@data$Group == "AIUP"),
    frac_train*length(which(meta_horne_f@data$Group == "AIUP"))
  )
)
horne_test_indices <- (1:nrow(filt_horne_f))[
  !((1:nrow(filt_horne_f) %in% horne_train_indices))
]
horne_train_rows <- horne_train_indices
horne_test_rows <- horne_test_indices
knn_horne_genes_df <- hg2_probe_map[hg2_probe_map$SYMBOL %in% 
                                      as.character(knn_gene_symbols),] %>%
    dplyr::select(., -PROBEID) %>%
    unique()
knn_horne_genes <- knn_horne_genes_df$ENSEMBL[
  knn_horne_genes_df$ENSEMBL %in% valid_ensembl
]
writexl::write_xlsx(
  knn_horne_genes_df,
  file.path("Results", "KNN_Horne_genes.xlsx")
)
filt_horne_s <- filt_horne_f[,knn_horne_genes] %>%
  dplyr::mutate(
    .,
    Sample = gsub(".CEL$","",filt_horne_f$Sample),
    Location = (meta_horne_f@data$Group == "EP") + 0.0,
  )
horne_pca <- FactoMineR::PCA(
  dplyr::select(filt_horne_s[horne_train_rows,], -Location, -Sample),
  graph=FALSE,
  ncp = 10
)
horne_train_pca <- horne_pca$ind$coord[,c("Dim.1","Dim.2")]
horne_test_pca <- FactoMineR::predict.PCA(
  horne_pca,
  filt_horne_s[horne_test_rows,c(knn_horne_genes,"Location","Sample")]
)$coord[,c("Dim.1","Dim.2")]
filt_horne_s <- dplyr::select(filt_horne_s, Sample, Location) %>%
  dplyr::mutate(Dim.1 = NA, Dim.2 = NA)
filt_horne_s$Dim.1[horne_train_rows] <- horne_train_pca[,"Dim.1"]
filt_horne_s$Dim.2[horne_train_rows] <- horne_train_pca[,"Dim.2"]
filt_horne_s$Dim.1[horne_test_rows] <- horne_test_pca[,"Dim.1"]
filt_horne_s$Dim.2[horne_test_rows] <- horne_test_pca[,"Dim.2"]

# A scree plot was generated for the Horne lab data.
pca_df <- horne_pca$eig[,"percentage of variance", drop = FALSE] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("PC") %>%
  dplyr::mutate(
      PC = gsub("comp ","",PC)
  ) %>%
  dplyr::mutate(PC = factor(PC, levels = 1:length(PC))) %>%
  dplyr::rename(var_percent = "percentage of variance")

plt <- ggplot(
  dplyr::mutate(pca_df, PC = 1:dplyr::n()),
  aes(PC, var_percent)
)+
  geom_point()+
  geom_line(colour = "red")+
  scale_y_continuous(
    limits = c(0,100),
    expand = c(0,0)
  )+
  scale_x_continuous(breaks = 1:16)+
  xlab("Principal Component")+ylab("Variance Explained (%)")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Scree_Plot_Normalized_KNN_Horne.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


A heatmap depicting how each variable contributes to the variance explained across principal components was also generated.
```{r message=FALSE, warning=FALSE, fig.width=4.85, fig.height=3}
pca_df_plt_horne <- horne_pca$var$contrib %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Gene") %>%
  dplyr::mutate(
    Gene = ensembl_to_symbol[Gene]
  ) %>%
  tidyr::gather("PC", "Variance Explained (%)", -Gene) %>%
  dplyr::mutate(
    PC = gsub("Dim.","",PC)
  ) %>%
  dplyr::mutate(
    Gene = factor(Gene, levels = rev(sort(unique(Gene)))),
    PC = factor(
      PC, levels = 1:length(unique(PC)), labels = 1:length(unique(PC))
    )
  )
pcs <- sort(unique(pca_df_plt_horne$PC))
for(i in 1:length(pcs)){
  pc_name <- pcs[i]
  pca_df_plt_horne$`Variance Explained (%)`[
    pca_df_plt_horne$PC == pc_name
  ] <- pca_df_plt_horne$`Variance Explained (%)`[
    pca_df_plt_horne$PC == pc_name]*train_pca$eig[
      paste0("comp ", i),"percentage of variance"
    ]/100
}

# Plot the variance explained as a heatmap.
plt <- ggplot(
  pca_df_plt_horne,
  aes(PC, Gene, fill = `Variance Explained (%)`)
)+
  geom_tile(colour = "black")+
  scale_fill_continuous(low = "white", high = "red", limits = c(0,15))+
  scale_x_discrete(position = "top", expand = c(0,0))+
  scale_y_discrete(expand = c(0,0))+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  labs(fill = "Variance\nExplained (%)")+
  theme(
    axis.title.y = element_blank()
  )+
  xlab("Principal Component")

# Save the plot.
cowplot::save_plot(
  file.path("Results","Discovery_PCA_Variance_Heatmap_Horne.tiff"),
  plt,
  base_width = 4.85, base_height = 3
)

# Display the plot.
plt
```


A scatterplot of Horne lab data projected into the PCA space was also generated.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
# Determine variation in each axis.
pca_df <- tibble::data_frame(
  var_percent = horne_pca$eig[,"percentage of variance"],
  PC = paste(
    paste0("PC", 1:length(var_percent)),
    paste0("(", round(var_percent, 1), "%)")
  )
)
pca_filt_df <- dplyr::mutate(
    filt_horne_s,
    Data = ifelse(1:dplyr::n() %in% horne_train_rows, "Train", "Test")
  ) %>%
    dplyr::mutate(
      Data = factor(Data, levels = c("Train","Test")),
      Location = factor(
        Location,
        levels = c(0,1),
        labels = c("AIUP","ECT")
      ),
      GROUP = factor(Sample)
    )
plt <- ggplot(

)+
  geom_line(
    data = dplyr::filter(pca_filt_df, Sample %in% Sample[duplicated(Sample)]),
    mapping = aes(Dim.1, Dim.2, group = GROUP),
    colour = "black"
  )+
  geom_point(
    data = pca_filt_df,
    mapping = aes(Dim.1, Dim.2, colour = Data, shape = Location)
  )+
  xlab(pca_df$PC[1])+ylab(pca_df$PC[2])+
  geom_hline(yintercept = 0, colour = "gray", linetype = "dashed")+
  geom_vline(xintercept = 0, colour = "gray", linetype = "dashed")+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff"))
  
# Save the plot.
cowplot::save_plot(
  file.path("Results", "PCA_Normalized_For_KNN_Horne_Lab_Data.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot.
plt
```


The model was evaluated with different values of k.
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
max_accuracy <- 0
best_i <- 1
horne_model_selection <- tibble::data_frame()
for(i in best_i:8){
  preds_horne_train <- knn_predictor(
    filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
    filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
    k = i,
    same = TRUE
  )
  accuracy <- mean(preds_horne_train$Prediction_Correct)
  if(accuracy > max_accuracy){
    max_accuracy <- accuracy
    best_i <- i
  }
  horne_model_selection <- dplyr::bind_rows(
    horne_model_selection,
    tibble::data_frame(
      `k` = i,
      Accuracy = 100*accuracy,
      N = length(horne_train_rows)
    )
  )
}
horne_model_selection <- dplyr::mutate(
  horne_model_selection,
  k = factor(k)
)

plt <- ggplot(
  horne_model_selection,
  aes(k, Accuracy, group = 1)
)+
  geom_point()+
  geom_line(colour = "red")+
  scale_y_continuous(
    limits = c(0,1000),
    expand = expand_scale(mult = c(0,0), add= c(0,0)),
    breaks = seq(0,100,25)
  )+
  ylab("Accuracy (%)")+
  coord_cartesian(ylim = c(0,100))+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)

# Save the plot.
cowplot::save_plot(
  file.path("Results","Horne_k_selection_accuracy.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Display the plot.
plt
```


Predictions were next made on the Horne lab data set.
```{r message=FALSE, warning=FALSE}
horne_k <- best_i
preds_horne_train <- knn_predictor(
  filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
  filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
  k = horne_k,
  same = TRUE
)
preds_horne_test <- knn_predictor(
  filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
  filt_horne_s[horne_test_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
  k = horne_k
)
writexl::write_xlsx(
  filt_horne_s[horne_test_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
  file.path("Results","Train_Norm.xlsx")
)
writexl::write_xlsx(
  preds_horne_test,
  file.path("Results","KNN_preds_horne_test.xlsx")
)
```


An ROC curve for the Horne lab training data was generated.
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
# Generate the ROC curve.
roc_horne_train_df <- dplyr::mutate(
    preds_horne_train,
    Location = as.numeric(Location == "Ectopic"),
    Prediction = factor(Prediction_Numeric, levels = c(0,1)),
    Probability = Ectopic_Probability
  ) %>%
    dplyr::select(Sample, Location, Prediction, Probability)
roc_horne_train <- make_roc(roc_horne_train_df)

# Save the ROC curve.
cowplot::save_plot(
  file.path("Results", "ROC_Horne_Train.tiff"),
  roc_horne_train$plt,
  base_width = 4, base_height = 4
)

# Plot the ROC curve.
roc_horne_train$plt

# Print the AUC.
print(paste0("AUC = ", round(roc_horne_train$auc,2)))
```


An ROC curve for the Horne lab testing data was generated.
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
# Generate the ROC curve.
roc_horne_df <- dplyr::mutate(
    preds_horne_test,
    Location = as.numeric(Location == "Ectopic"),
    Prediction = factor(Prediction_Numeric, levels = c(0,1)),
    Probability = Ectopic_Probability
  ) %>%
    dplyr::select(Sample, Location, Prediction, Probability)
roc_horne <- make_roc(roc_horne_df)

# Save the ROC curve.
cowplot::save_plot(
  file.path("Results", "ROC_Horne_Test.tiff"),
  roc_horne$plt,
  base_width = 4, base_height = 4
)

# Plot the ROC curve.
roc_horne$plt

# Print the AUC.
print(paste0("AUC = ", round(roc_horne$auc,2)))
```


All of the ROC curves were also merged into one figure.
```{r message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
# Retrieve the sensitivity and specificity values.
get_s_and_s <- function(df, data_set){
  df_pred <- ROCR::prediction(
    as.numeric(as.character(df$Probability)),
    as.numeric(as.character(df$Location))
  )
  df_pred_dat <- ROCR::performance(
    df_pred, "tpr", "fpr"
  )
  df_pred_df <- tibble::data_frame(
    `False positive rate` = df_pred_dat@x.values %>% unlist(),
    `True positive rate` = df_pred_dat@y.values %>% unlist(),
    data_set = data_set
  )
  return(df_pred_df)
}
ss_train <- get_s_and_s(knn_predictions_train_roc, "Train")
ss_test <- get_s_and_s(knn_predictions_test_roc, "Test")
ss_horne_train <- get_s_and_s(roc_horne_train_df, "Horne_Train")
ss_horne <- get_s_and_s(roc_horne_df, "Horne_Test")

ss_df <- dplyr::bind_rows(ss_train, ss_test, ss_horne_train, ss_horne) %>%
  dplyr::mutate(data_set = factor(
    data_set,
    levels = c("Train", "Test", "Horne_Train", "Horne_Test"),
    labels = c(
      "Discovery", "Prospective", "External - Train", "External - Test"
    ))
  )

# Plot the curve.
plt <- ggplot(
  ss_df,
  aes(`False positive rate`, `True positive rate`, colour = data_set)
)+
  geom_point()+
  geom_line(alpha = 0.3, size = 1.2)+
  coord_cartesian(xlim = c(0,1), ylim = c(0,1), expand = c(0,0))+
  geom_abline(slope = 1, intercept = 0, col = "black", linetype = "dashed")+
  coord_equal()+
  theme(legend.title = element_blank(), legend.position = c(0.5,0.15))+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933","#e27ded"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933","#e27ded"))+
  xlab("False Positive Rate")+ylab("True Positive Rate")

# Save the plot.
cowplot::save_plot(
  file.path("Results", "ROC_All.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Display the plot
plt
```


The results were summarized in tabular format as well.
```{r message=FALSE, warning=FALSE}
# Summarize the results.
summarize_results <- function(preds, title, subtitle, naive_class, reps, k_n){
  # Calculate accuracy and accuracy using the naive model.
  accuracy <- mean(preds$Prediction_Correct)
  naive_accuracy <- sum(preds$Location == naive_class)/nrow(preds)
  
  # Resample for bootstrapping.
  set.seed(123456789)
  indices <- sample(1:nrow(preds), reps*nrow(preds), replace = TRUE)
  
  # Retrieve the data.
  probs <- matrix(preds$Ectopic_Probability[indices], ncol = reps)
  class_labels <- matrix(preds$Class_Numeric[indices], ncol = reps)
  
  # Remove one class data sets.
  bad_indices <- which(abs(colMeans(class_labels) - 0.5) >= 0.5)
  if(length(bad_indices)){
    probs <- probs[,-bad_indices]
    class_labels <- class_labels[,-bad_indices]
  }
  
  roc_pred <- ROCR::prediction(
    probs,
    class_labels
  )
  roc_perf <- ROCR::performance(roc_pred, measure = "tpr", x.measure = "fpr")
  roc_df <- tibble::data_frame(
    `False positive rate` = roc_perf@x.values %>% unlist(),
    `True positive rate` = roc_perf@y.values %>% unlist(),
    rep_number = NA
  )
  j <- 1
  for(i in seq_along(roc_perf@x.values)){
    for(k in 1:length(roc_perf@x.values[[i]])){
      roc_df$rep_number[j] <- i
      j <- j+1
    }
  }
  auc <- ROCR::performance(roc_pred, "auc")
  mean_auc <- auc@y.values %>% unlist() %>% mean()
  
  num_lines <- 10
  lines_to_keep <- sample(roc_df$rep_number, num_lines)
  plt_auc_all <- ggplot(
    dplyr::filter(roc_df, rep_number %in% lines_to_keep),
    aes(`False positive rate`, `True positive rate`, group = rep_number)
  )+
    # geom_line(alpha = 0.05)+
    geom_step(alpha = 0.3)+
    theme(plot.margin = margin(r = 15, t = 15))+
    geom_abline(slope = 1, intercept = 0, colour = "red", linetype = "dashed")+
    coord_equal(xlim=c(-0.1,1.1), ylim=c(-0.1,1.1), expand = c(0,0))+
    scale_x_continuous(breaks = seq(0,1,0.25))+
    scale_y_continuous(breaks = seq(0,1,0.25))+
    annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
    annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
    xlab("False Positive Rate")+ylab("True Positive Rate")
  
  temp_data <- dplyr::mutate(
        roc_df,
        fpr_c = `False positive rate`
    ) %>%
    dplyr::group_by(., fpr_c) %>%
    dplyr::summarise(
        .,
        `False positive rate` = mean(`False positive rate`),
        `True positive rate` = mean(`True positive rate`)
    )
  
  plt_auc_hist <- ggplot(
    tibble::data_frame(auc = auc@y.values %>% unlist()),
    aes(auc)
  )+
    geom_histogram(binwidth = 0.05, aes(y = ..density..))+
    geom_vline(xintercept = mean_auc, colour = "red")+
    coord_cartesian(xlim = c(0,1))+
    scale_x_continuous(expand = c(0,0,0,0))+
    scale_y_continuous(
      expand = expand_scale(
        mult = c(0,0.15),
        add = c(0,0)
      )
    )+
    theme(plot.margin = margin(r=0.5,t=0.5, unit = "cm"))+
    xlab("AUC")+ylab("Probability density")+
    annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
    annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)
  
  bs_accuracy <- (matrix(preds$Prediction_Numeric[indices], ncol = reps) ==
  matrix(preds$Class_Numeric[indices], ncol = reps)) %>%
    colMeans(.) %>%
    matrix(., ncol = 1) %>%
    tibble::as_tibble() %>%
    dplyr::rename(., Accuracy = "V1") %>%
    dplyr::mutate(., Accuracy = 100*Accuracy)
  
  plt_acc_hist <- ggplot(
    bs_accuracy,
    aes(Accuracy)
  )+
  geom_histogram(aes(y=..density..), binwidth = 5)+
  geom_vline(xintercept = naive_accuracy*100, colour = "red")+
    coord_cartesian(xlim = c(0,100))+
    scale_x_continuous(expand = c(0,0,0,0))+
    scale_y_continuous(
      expand = expand_scale(
        mult = c(0,0.15),
        add = c(0,0)
      )
    )+
    theme(plot.margin = margin(r = 15, t = 15))+
    xlab("Accuracy (%)")+ylab("Probability density")+
    annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
    annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)
  
  
  confusion_matrix <- caret::confusionMatrix(
    factor(preds$Prediction_Numeric, levels = c(0,1)), 
    factor(preds$Class_Numeric, levels = c(0,1))
  )
  
  sensitivity <- confusion_matrix$byClass["Sensitivity"]
  specificity <- confusion_matrix$byClass["Specificity"]
  true_positives <- confusion_matrix$table[1,1]
  true_negatives <- confusion_matrix$table[2,2]
  false_positives <- confusion_matrix$table[2,1]
  false_negatives <- confusion_matrix$table[1,2]
  
  N <- sum(confusion_matrix$table)
  
  true_positive_frac <- true_positives/N
  true_negative_frac <- true_negatives/N
  false_positive_frac <- false_positives/N
  false_negative_frac <- false_negatives/N
  
  # Assemble results.
  results_summary <- tibble::data_frame(
    Dataset = title,
    Subset = subtitle,
    Accuracy = accuracy,
    Naive_Accuracy = naive_accuracy,
    Naive_Class = naive_class,
    AUROC = mean_auc,
    Sensitivity = sensitivity,
    Specificity = specificity,
    True_Positives = true_positives,
    True_Negatives = true_negatives,
    False_Positives = false_positives,
    False_Negatives = false_negatives,
    N = length(unique(preds$Sample)),
    N_IUP = table((unique(preds[,c("Sample","Location")]))$Location)["AIUP"],
    N_Ectopic = table(
      unique(preds[,c("Sample","Location")])$Location
    )["Ectopic"],
    True_Positives_Proportion = true_positive_frac,
    True_Negatives_Proportion = true_negative_frac,
    False_Positives_Proportion = false_positive_frac,
    False_Negatives_Proportion = false_negative_frac,
    k = k_n,
    Bootstrap_Resamplings = reps,
    Genes = paste(genes_of_interest, collapse = ",")
  )
  
  plots <- tibble::lst(
    plt_auc_all = plt_auc_all,
    plt_auc_hist = plt_auc_hist,
    plt_acc_hist = plt_acc_hist
  )

  preds_out <- preds
  all_cols <- colnames(preds_out)
  if(any(all_cols == "location")){
    all_cols[all_cols == "location"] <- "Location"
  }
  colnames(preds_out) <- all_cols
  preds_out <- preds_out[,colnames(preds_out) %in% c(
    "Sample", "Location", "Prediction", "Ectopic_Probability", 
    "Prediction_Correct", "Initially_PUL"
  )]
  
  # Create the output object.
  tibble::lst(
    plots = plots,
    results_summary = results_summary,
    predictions = preds_out
  )
}

set.seed(123456789)
reps <- 100
genes_of_interest <- knn_gene_symbols
train_out <- summarize_results(preds_train, "Train", "", "AIUP", reps, k)
test_out <- summarize_results(preds_test, "Test", "", "AIUP", reps, k)
genes_of_interest <- sort(knn_horne_genes_df$SYMBOL)
horne_out_train <- summarize_results(
  preds_horne_train, "Horne", "Train", "Ectopic", reps, horne_k
)
horne_out_test <- summarize_results(
  preds_horne_test, "Horne", "Test", "Ectopic", reps, horne_k
)


```


Figures related to the bootstraps above were plotted and saved to the *Results* folder.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=6.5}
# ROC plots.
plt <- cowplot::plot_grid(
  train_out$plots$plt_auc_all+
    ggtitle("Discovery")+
    theme(plot.title = element_text(face = "plain")),
  test_out$plots$plt_auc_all+
    ggtitle("Prospective")+
    theme(plot.title = element_text(face = "plain")),
  horne_out_train$plots$plt_auc_all+
    ggtitle("External - Train")+
    theme(plot.title = element_text(face = "plain")),
  horne_out_test$plots$plt_auc_all+
    ggtitle("External - Test")+
    theme(plot.title = element_text(face = "plain")),
  rel_widths = 0.9, rel_heights = 0.9
)
cowplot::save_plot(
  file.path("Results","ROC_Bootsraps.tiff"),
  plt,
  base_width = 6.5, base_height = 6.5
)
plt

# AUC Histograms.
plt <- cowplot::plot_grid(
  train_out$plots$plt_auc_hist+
    ggtitle("Discovery")+
    theme(plot.title = element_text(face = "plain")),
  test_out$plots$plt_auc_hist+
    ggtitle("Prospective")+
    theme(plot.title = element_text(face = "plain")),
  horne_out_train$plots$plt_auc_hist+
    ggtitle("External - Train")+
    theme(plot.title = element_text(face = "plain")),
  horne_out_test$plots$plt_auc_hist+
    ggtitle("External - Test")+
    theme(plot.title = element_text(face = "plain")),
  rel_widths = 0.9, rel_heights = 0.9
)
cowplot::save_plot(
  file.path("Results","AUC_Histogram_Bootstraps.tiff"),
  plt,
  base_width = 6.5, base_height = 6.5
)
plt

# Accuracy Histograms.
plt <- cowplot::plot_grid(
  train_out$plots$plt_acc_hist+
    ggtitle("Discovery")+
    theme(plot.title = element_text(face = "plain")),
  test_out$plots$plt_acc_hist+
    ggtitle("Prospective")+
    theme(plot.title = element_text(face = "plain")),
  horne_out_train$plots$plt_acc_hist+
    ggtitle("External - Train")+
    theme(plot.title = element_text(face = "plain")),
  horne_out_test$plots$plt_acc_hist+
    ggtitle("External - Test")+
    theme(plot.title = element_text(face = "plain")),
  rel_widths = 0.9, rel_heights = 0.9
)
cowplot::save_plot(
  file.path("Results","Accuracy_Bootstraps.tiff"),
  plt,
  base_width = 6.5, base_height = 6.5
)
plt
```


Key modeling statistics were aggregated.
```{r message=FALSE, warning=FALSE}
# Aggregate modeling results.
modeling_summary <- dplyr::bind_rows(
  train_out$results_summary,
  test_out$results_summary,
  horne_out_train$results_summary,
  horne_out_test$results_summary
)

# Save the summary.
writexl::write_xlsx(
  modeling_summary,
  file.path("Results", "KNN_Summary_Modeling.xlsx")
)

# Display the summary.
knitr::kable(modeling_summary, format = "pandoc")
```


# ROC curves for bootstraps


ROC curves for bootstraps were plotted.
```{r message=FALSE, warning=FALSE}
bs_roc_maker <- function(
  reference,
  target,
  k,
  same = FALSE
){
  set.seed(123456789)
  reference$Location <- c(
    "0" = "AIUP", "1" = "Ectopic"
  )[as.character(reference$Location)]
  target$Location <- c(
    "0" = "AIUP", "1" = "Ectopic"
  )[as.character(target$Location)]
  
  # Make predictions
  num_resamples <- 1000
  train_frac <- 0.7
  if(same){
    out <- lapply(
      1:num_resamples,
      function(ITERATION){
        inner_ref <- reference
        train_ind <- c(
          sample(
            which(inner_ref$Location == "AIUP"), 
            train_frac*sum(inner_ref$Location == "AIUP"), 
            replace = FALSE
          ),
          sample(
            which(inner_ref$Location == "Ectopic"), 
            train_frac*sum(inner_ref$Location == "Ectopic"), 
            replace = FALSE
          )
        )
        test_ind <- (1:nrow(inner_ref))[!((1:nrow(inner_ref)) %in% train_ind)]
        predictions <- class::knn(
          train = inner_ref[train_ind,grepl("^Dim.", colnames(inner_ref))],
          test = target[test_ind,grepl("^Dim.", colnames(inner_ref))],
          cl = inner_ref$Location[train_ind],
          k = k,
          prob = TRUE
        )
        
        # Determine the probability of an ectopic.
        prob <- attr(predictions, "prob")
        predictions[prob == 0.5] <- "AIUP" # Default prediction is AIUP.
        pred_num <- as.numeric(predictions == "Ectopic")
        prob[pred_num == 0] <- 1 - prob[pred_num == 0]

        # Create the output object.
        out <- dplyr::select(
          target[test_ind,],
          Sample, Location
        ) %>%
          dplyr::mutate(
            .,
            Prediction = predictions,
            Ectopic_Probability = prob,
            Prediction_Numeric = pred_num,
            Class_Numeric = as.numeric(Location == "Ectopic"),
            Prediction_Correct = Location == as.character(Prediction),
            Iteration = ITERATION
          )
        
        if("initially_pul" %in% colnames(inner_ref)){
          out[,"initially_pul"] <- inner_ref$initially_pul[test_ind]
        }
        
        return(out)
      }
    ) %>%
    dplyr::bind_rows()
  }else{
    out <- lapply(
      1:num_resamples,
      function(ITERATION){
        inner_ref <- reference
        train_ind <- c(
          sample(
            which(inner_ref$Location == "AIUP"), 
            train_frac*sum(inner_ref$Location == "AIUP"), 
            replace = FALSE
          ),
          sample(
            which(inner_ref$Location == "Ectopic"), 
            train_frac*sum(inner_ref$Location == "Ectopic"), 
            replace = FALSE
          )
        )
        predictions <- class::knn(
          train = inner_ref[train_ind,grepl("^Dim.", colnames(inner_ref))],
          test = target[,grepl("^Dim.", colnames(inner_ref))],
          cl = inner_ref$Location[train_ind],
          k = k,
          prob = TRUE
        )
        
        # Determine the probability of an ectopic.
        prob <- attr(predictions, "prob")
        predictions[prob == 0.5] <- "Ectopic" # Default prediction is Ectopic.
        pred_num <- as.numeric(predictions == "Ectopic")
        prob[pred_num == 0] <- 1 - prob[pred_num == 0]
  
        # Create the output object.
        out <- dplyr::select(
          target,
          Sample, Location
        ) %>%
          dplyr::mutate(
            .,
            Prediction = predictions,
            Ectopic_Probability = prob,
            Prediction_Numeric = pred_num,
            Class_Numeric = as.numeric(Location == "Ectopic"),
            Prediction_Correct = Location == as.character(Prediction),
            Iteration = ITERATION
          )
        
        if("initially_pul" %in% colnames(inner_ref)){
          out[,"initially_pul"] <- target$initially_pul
        }
        
        return(out)
      }
    ) %>%
      dplyr::bind_rows()
  }

  return(out)
}


preds_bs_train <- bs_roc_maker(
    knn_model_df_train[,c(c("Dim.1","Dim.2"),"Location","Sample")],
    knn_model_df_train[,c(c("Dim.1","Dim.2"),"Location","Sample")],
    k = k,
    same = TRUE
  )
preds_bs_test <- bs_roc_maker(
    knn_model_df_train[,c(c("Dim.1","Dim.2"),"Location","Sample")],
    knn_model_df_test[,c(c("Dim.1","Dim.2"),"Location","Sample")],
    k = k,
    same = FALSE
  )
preds_bs_horne_train <- bs_roc_maker(
    filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
    filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
    k = horne_k,
    same = TRUE
  )
preds_bs_horne_test <- bs_roc_maker(
    filt_horne_s[horne_train_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
    filt_horne_s[horne_test_rows,c(c("Dim.1","Dim.2"),"Location","Sample")],
    k = horne_k,
    same = FALSE
  )

# Retrieve the sensitivity and specificity values.
get_bs_s_and_s <- function(df, data_set){
  df <- dplyr::select(
    df,
    Sample, Class_Numeric, Prediction_Numeric, Ectopic_Probability, Iteration
  ) %>%
    dplyr::rename(
      Location = "Class_Numeric",
      Prediction = "Prediction_Numeric",
      Probability = "Ectopic_Probability"
    )
  dfs <- split(df, f = factor(df$Iteration))
  out <- lapply(
    dfs,
    function(x){
      iteration <- x$Iteration[1]
      x <- dplyr::select(x, -Iteration)
      df_pred <- ROCR::prediction(
        as.numeric(as.character(x$Probability)),
        as.numeric(as.character(x$Location))
      )
      df_pred_dat <- ROCR::performance(
        df_pred, "tpr", "fpr"
      )
      df_pred_df <- tibble::data_frame(
        `False positive rate` = df_pred_dat@x.values %>% unlist(),
        `True positive rate` = df_pred_dat@y.values %>% unlist(),
        data_set = data_set
      )
      df_pred_df <- dplyr::mutate(
        df_pred_df,
        Iteration = iteration
      )
      return(df_pred_df)
    }
  ) %>%
    dplyr::bind_rows() %>%
    dplyr::mutate(Iteration = factor(Iteration))
  
  return(out)
}

bs_ss_train <- get_bs_s_and_s(preds_bs_train, "Train")
bs_ss_test <- get_bs_s_and_s(preds_bs_test, "Test")
bs_ss_horne_train <- get_bs_s_and_s(preds_bs_horne_train, "Horne_Train")
bs_ss_horne <- get_bs_s_and_s(preds_bs_horne_test, "Horne_Test")


# Plot the curves.
make_bs_roc_plot <- function(df, NAME){
  plt <- ggplot(
    df,
    aes(`False positive rate`, `True positive rate`, group = Iteration)
  )+
    # geom_point()+
    geom_line(alpha = 0.01, size = 1.2)+
    coord_cartesian(xlim = c(0,1), ylim = c(0,1), expand = c(0,0))+
    geom_abline(slope = 1, intercept = 0, col = "black", linetype = "dashed")+
    coord_equal()+
    theme(legend.title = element_blank(), legend.position = c(0.4,0.15))+
    annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
    annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
    annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
    xlab("False Positive Rate")+ylab("True Positive Rate")
  
  # Save the plot.
  cowplot::save_plot(
    file.path("Results", paste0(NAME, ".tiff")),
    plt,
    base_width = 4, base_height = 4
  )
  
  return(plt)
}

bs_roc_train <- make_bs_roc_plot(bs_ss_train, "BS_Discovery_ROC")
bs_roc_test <- make_bs_roc_plot(bs_ss_test, "BS_Prospective_ROC")
bs_roc_horne_train <- make_bs_roc_plot(bs_ss_horne_train, "BS_Horne_Train")
bs_roc_horne_train <- make_bs_roc_plot(bs_ss_horne, "BS_Horne_Test")

get_aucs <- function(df){
  dfs <- split(df, f = df$Iteration)
  aucs <- sapply(
    dfs,
    function(x){
      roc <- pROC::roc(
        response = x$Class_Numeric,
        predictor = x$Ectopic_Probability
      )
      
      auc <- pROC::auc(roc)[1]
      return(auc)
    }
  )
  return(aucs)
}

aucs_bs_train <- get_aucs(preds_bs_train)
aucs_bs_test <- get_aucs(preds_bs_test)
aucs_bs_horne_train <- get_aucs(preds_bs_horne_train)
aucs_bs_horne_test <- get_aucs(preds_bs_horne_test)

get_ss_bs <- function(df){
  dplyr::group_by(
    df,
    Iteration
  ) %>%
    dplyr::mutate(
      tp = Prediction_Correct & (Class_Numeric == 1),
      fp = !Prediction_Correct & (Class_Numeric == 0),
      fn = !Prediction_Correct & (Class_Numeric == 1),
      tn = Prediction_Correct & (Class_Numeric == 0)
    ) %>%
    dplyr::summarise(
      tp = sum(tp),
      fp = sum(fp),
      fn = sum(fn),
      tn = sum(tn)
    ) %>%
    dplyr::mutate(
      sensitivity = tp/(tp+fn),
      specificity = tn/(tn+fp)
    ) %>%
    dplyr::ungroup()
}

ss_bs_df <- dplyr::bind_rows(
  Discovery = get_ss_bs(preds_bs_train) %>%
    dplyr::mutate(Data = "Discovery"),
  Prospective = get_ss_bs(preds_bs_test) %>%
    dplyr::mutate(Data = "Prospective"),
  `External - Train` = get_ss_bs(preds_bs_horne_train) %>%
    dplyr::mutate(Data = "External - Train"),
  `External - Test` = get_ss_bs(preds_bs_horne_test) %>%
    dplyr::mutate(Data = "External - Test")
) %>%
  # tidyr::gather("Data", "AUC") %>%
  dplyr::mutate(
    Data = factor(
      Data,
      levels = c(
        "Discovery", "Prospective",
        "External - Train", "External - Test"
      )
    )
  )

ss_df <- dplyr::group_by(ss_bs_df, Data) %>%
  dplyr::mutate(
    N = dplyr::n(),
    SENSITIVITY = (sensitivity),
    SENSITIVITY_CI = sqrt(sensitivity*(1-sensitivity)/(tp+fn))*qnorm(0.025),
    SENSITIVITY_LOW = SENSITIVITY + SENSITIVITY_CI,
    SENSITIVITY_HIGH = SENSITIVITY - SENSITIVITY_CI,
    SPECIFICITY = (specificity),
    SPECIFICITY_CI = sqrt(specificity*(1-specificity)/(fp+tn))*qnorm(0.025),
    SPECIFICITY_LOW = SPECIFICITY + SPECIFICITY_CI,
    SPECIFICITY_HIGH = SPECIFICITY - SPECIFICITY_CI
  ) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(
    SENSITIVITY_LOW = ifelse(SENSITIVITY_LOW < 0, 0, SENSITIVITY_LOW),
    SENSITIVITY_HIGH = ifelse(SENSITIVITY_HIGH > 1, 1, SENSITIVITY_HIGH),
    SPECIFICITY_LOW = ifelse(SPECIFICITY_LOW < 0, 0, SPECIFICITY_LOW),
    SPECIFICITY_HIGH = ifelse(SPECIFICITY_HIGH > 1, 1, SPECIFICITY_HIGH)
  )

ss_df_summary <- dplyr::group_by(
  ss_df, Data
) %>%
  dplyr::summarise(
    sensitivity_over = mean(SENSITIVITY_LOW > 0),
    specificity_over = mean(SPECIFICITY_LOW > 0),
    SENSITIVITY_CI = mean(SENSITIVITY_CI),
    SPECIFICITY_CI = mean(SENSITIVITY_CI),
    SENSITIVITY = mean(SENSITIVITY),
    SENSITIVITY_LOW = SENSITIVITY + SENSITIVITY_CI,
    SENSITIVITY_HIGH = SENSITIVITY - SENSITIVITY_CI,
    SPECIFICITY = mean(SPECIFICITY),
    SPECIFICITY_LOW = SPECIFICITY + SPECIFICITY_CI,
    SPECIFICITY_HIGH = SPECIFICITY - SPECIFICITY_CI
  ) %>%
  dplyr::ungroup()

plt <- ggplot(
  ss_df_summary,
  aes(Data, SENSITIVITY)
)+
  geom_bar(stat = "identity")+
  geom_errorbar(
    mapping = aes(
      ymin = SENSITIVITY_LOW,
      ymax = SENSITIVITY_HIGH
    ),
    width = 0.2
  )+
  panel_border(colour = "black", size = 1)+
  coord_cartesian(ylim = c(0,1.05))+
  scale_y_continuous(
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    )
  )+
  ylab("Sensitivity")+
  theme(
    axis.title.x = element_blank()
  )

cowplot::save_plot(
  file.path("Results", "Sensitivity.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

plt

plt <- ggplot(
  ss_df_summary,
  aes(Data, SPECIFICITY)
)+
  geom_bar(stat = "identity")+
  geom_errorbar(
    mapping = aes(
      ymin = SPECIFICITY_LOW,
      ymax = SPECIFICITY_HIGH
    ),
    width = 0.2
  )+
  panel_border(colour = "black", size = 1)+
  coord_cartesian(ylim = c(0,1.05))+
  scale_y_continuous(
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    )
  )+
  ylab("Specificity")+
  theme(
    axis.title.x = element_blank()
  )

cowplot::save_plot(
  file.path("Results", "Specificity.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

plt

auc_df <- tibble::data_frame(
  Discovery = aucs_bs_train,
  Prospective = aucs_bs_test,
  `External - Train` = aucs_bs_horne_train,
  `External - Test` = aucs_bs_horne_test
) %>%
  tidyr::gather("Data", "AUC") %>%
  dplyr::mutate(
    Data = factor(
      Data,
      levels = c(
        "Discovery", "Prospective",
        "External - Train", "External - Test"
      )
    )
  )

plt <- ggplot(
  auc_df,
  aes(AUC)
)+
  geom_histogram(aes(y = ..density..), breaks = seq(0,1,0.1))+
  facet_wrap(~Data, scales = "free")+
  coord_cartesian(xlim = c(0,1))+
  scale_y_continuous(
    expand = expand_scale(
      mult = c(0,0.1),
      add = c(0,0)
    )
  )+
  scale_x_continuous(
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    )
  )+
  theme(
    strip.background = element_blank(),
    plot.margin = margin(r = 1, t = 1, l = 1, unit = "cm"),
    panel.spacing = unit(1.5, "lines")
  )+
  ylab("Probability Density")+
  panel_border(colour = "black", size = 1)

cowplot::save_plot(
  file.path("Results", "AUC_BS_Histograms.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
```


# Gene expression heatmap
A heat map of gene expression levels in the discovery dataset was plotted.
```{r message=FALSE, warning=FALSE, results='hide'}
# Load the modeling data with gene information.
knn_model_df_train <- readxl::read_excel(
  file.path("Results","knn_model_data_discovery.xlsx")
)
knn_model_df_test <- readxl::read_excel(
  file.path("Results","knn_model_data_prospective.xlsx")
)
knn_model_df_horne <- filt_horne_f[,knn_horne_genes] %>%
  dplyr::mutate(
    .,
    Sample = gsub(".CEL$","",filt_horne_f$Sample),
    Location = (meta_horne_f@data$Group == "EP") + 0.0,
  )
writexl::write_xlsx(
  knn_model_df_horne,
  file.path("Results","knn_model_data_horne.xlsx")
)

# Create the heatmap.
knn_df <- dplyr::mutate(knn_model_df_train, DataSet = "Train")

clustered <- hclust(
  dist(knn_df[,grepl("^ENSG",colnames(knn_df))])
)
predd <- as.dendrogram(clustered)
hclrs <- colorRampPalette(c("green", "black", "red"))(n = 200)
hclustAvg <- hclustAvg <- function(x){hclust(x, method = "average")}

library(gplots)
source(file.path("Scripts","KNN_heatmap.R"))
dev.off()
graphics.off()
```



![Gene Expression Heatmap](Results/KNN_train_heatmap.png "Heatmap Image")


# Plot expression levels for classifier genes
A paneled plot depicting the expression levels of the classifier genes was generated.
```{r message=FALSE, warning=FALSE}
organize_expression <- function(df, Data, Source){
  dplyr::mutate(
    df,
    Sample = gsub("MP", "", Sample),
    Data = Data
  ) %>%
    dplyr::rename(Label = "Location") %>%
    tidyr::gather("Gene", "Expression", -Sample, -Label, -Data) %>%
    dplyr::mutate(
      Gene = ensembl_to_symbol[Gene],
      Source = Source
    )
}
df <- dplyr::bind_rows(
  organize_expression(knn_model_df_train, "Train", "Microarray"),
  organize_expression(knn_model_df_test, "Test", "Microarray"),
  organize_expression(
    dplyr::mutate(
      filt_horne_f[,c(knn_horne_genes,"Sample")],
      Location = c("AIUP","ECT")[force(filt_horne_s$Location+1)]
    ),
    "Horne lab", "Microarray"
  )
) %>%
  dplyr::mutate(
    Expression = 2^Expression
  )
for(i in ensembl_to_symbol){
  aiup_mean <- mean(df$Expression[
    (df$Label == "AIUP") & (df$Data != "Horne lab") & (df$Gene == i)
  ])
  df$Expression[(df$Data != "Horne lab") & (df$Gene == i)] <- df$Expression[
    (df$Data != "Horne lab") & (df$Gene == i)
  ]/aiup_mean
  horne_mean <- df$Expression[
    (df$Label == "AIUP") & (df$Data == "Horne lab") & (df$Gene == i)
  ]
  if(length(horne_mean) > 0){
    df$Expression[(df$Data == "Horne lab") & (df$Gene == i)] <- df$Expression[
      (df$Data == "Horne lab") & (df$Gene == i)
    ]/mean(horne_mean)
  }
}
df <- dplyr::mutate(df, Label = factor(Label, levels = c("AIUP","ECT")))
df_norm_out <- dplyr::mutate(
    df,
    Sample = paste0("PUL_", Sample),
    Data = factor(
      as.character(Data),
      levels = c("Train", "Test"),
      labels = c("Discovery", "Prospective")
    )
  )
writexl::write_xlsx(
  df_norm_out,
  file.path("Results", "Microarray_Normalized_Data.xlsx")
)


# Generate graphs.
df_means <- dplyr::group_by(df, Label, Data, Gene) %>%
  dplyr::summarise(
    N = n(),
    SD = ifelse(N == 1, NA, sd(Expression)),
    se = ifelse(N == 1, 0, sd(Expression)/sqrt(N-1)),
    Expression = mean(Expression)
  ) %>%
  dplyr::ungroup()

# Plot the data.
df_plt <- dplyr::filter(df, Data != "Horne lab") %>%
  dplyr::mutate(Data = factor(
      Data,
      levels = c("Train", "Test"), labels = c("Discovery", "Prospective")
    ))
df_means_plt <- dplyr::filter(df_means, Data != "Horne lab") %>%
  dplyr::mutate(
    Data = factor(
      Data,
      levels = c("Train", "Test"), labels = c("Discovery", "Prospective")
    )
  )
plt <- ggplot(
  data = df_plt,
  aes(Label, Expression, colour = Data)
)+
  ggbeeswarm::geom_quasirandom(dodge.width = 0.9)+
  theme(
    strip.background = element_blank(),
    panel.spacing = unit(2, "lines")
  )+
  coord_cartesian(ylim = c(0,8), expand = FALSE)+
  geom_bar(
    data = df_means_plt,
    mapping = aes(Label, Expression, fill = Data),
    alpha = 0.3,
    stat = "identity", position = "dodge"
  )+
  geom_errorbar(
    data = df_means_plt,
    mapping = aes(
      ymin = Expression - se,
      ymax = Expression + se,
      group = Data
    ),
    position = position_dodge(width = 0.9),
    width = 0.2,
    colour = "black"
  )+
  facet_wrap(~Gene, scales = "free", nrow = 4)+
  theme(
    # legend.position = c(0.8,0.15),
    axis.title.x = element_blank()
  )+
  geom_signif(
    comparisons = list(c("AIUP","ECT")),
    map_signif_level = TRUE,
    colour = "black",
    test = "wilcox.test",
    test.args= c("alternative" = "less")
  )+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff"))+
  ylab("Relative Expression")

cowplot::save_plot(
  file.path("Results", "Microarray_Figure.tiff"),
  plt,
  base_height = 9, base_width = 6.5
)

# Perform statistics.
pairwise_comparisons <- SimplifyStats::pairwise_stats(
  dplyr::filter(df, Data != "Horne lab"),
  group_cols = c("Label", "Gene"),
  var_cols = "Expression",
  fxn = wilcox.test,
  alternative = "greater"
) %>%
  dplyr::filter(A.Gene == B.Gene) %>%
  dplyr::mutate(fdr = p.adjust(p.value, method = "fdr"))


# Output statistics.
writexl::write_xlsx(
  df_means, file.path("Results","Descriptive_Statistics.xlsx")
)
writexl::write_xlsx(
  pairwise_comparisons, file.path("Results","Pairwise_Tests.xlsx")
)
```


# Plot expression levels for possible loading controls


We proposed to use several genes as loading controls for qPCR and nCounter experiments. Thus, we sought to determine whether their expression levels were consistent between AIUP and ECT samples.


```{r message=FALSE, warning=FALSE, fig.height=4, fig.width=5.5}
rpl19_ensembl <- hg2_probe_map$ENSEMBL[hg2_probe_map$SYMBOL == "RPL19"]
pgk1_ensembl <- hg2_probe_map$ENSEMBL[hg2_probe_map$SYMBOL == "PGK1"]
gusb_ensembl <- hg2_probe_map$ENSEMBL[hg2_probe_map$SYMBOL == "GUSB"]

ensembl_ids <- c(rpl19_ensembl, pgk1_ensembl, gusb_ensembl)
hg2_probe_ids <- c(
  hg2_probe_map$PROBEID[hg2_probe_map$SYMBOL == "RPL19"][1],
  hg2_probe_map$PROBEID[hg2_probe_map$SYMBOL == "PGK1"][1],
  hg2_probe_map$PROBEID[hg2_probe_map$SYMBOL == "GUSB"][1]
)
gene_names <- c("RPL19", "PGK1", "GUSB")

# Format the data for each data set.
knn_model_df_train_hk <- format_data_for_model(
  cache_prefix = "knn_norm_",
  data_set = "MAMC_DCI__Train",
  hg2_probe_ids,
  addendum = "_hk"
)
colnames(knn_model_df_train_hk)[1:length(
  hg2_probe_ids
)] <- gene_names
saveRDS(knn_model_df_train_hk, file = file.path(
  "Cache", paste0("Model_values_", "knn_norm_", "MAMC_DCI__Train_hk", ".rds")
))
knn_model_df_test_hk <- format_data_for_model(
  cache_prefix = "knn_norm_",
  data_set = "MAMC_DCI__Test",
  hg2_probe_ids,
  addendum = "_hk"
)
colnames(knn_model_df_test_hk)[1:length(
  hg2_probe_ids
)] <- gene_names
saveRDS(knn_model_df_test_hk, file = file.path(
  "Cache", paste0("Model_values_", "knn_norm_", "MAMC_DCI__Test_hk", ".rds")
))

filt_horne_hk <- filt_horne_f[,c("Sample", ensembl_ids)] %>%
  dplyr::mutate(
    .,
    Sample = gsub(".CEL$","",filt_horne_f$Sample),
    Location = (meta_horne_f@data$Group == "EP") + 0.0,
  )
names(filt_horne_hk)[names(filt_horne_hk) %in% ensembl_ids] <- gene_names

# Merge data sets.
mdf <- dplyr::bind_rows(
  dplyr::mutate(knn_model_df_train_hk, Source = "Discovery"),
  dplyr::mutate(knn_model_df_test_hk, Source = "Prospective"),
  dplyr::mutate(filt_horne_hk, Source = "Horne lab")
) %>%
  dplyr::mutate(
    Location = factor(
      Location,
      levels = c(0,1),
      labels = c("AIUP", "ECT")
    ),
    Source = factor(
      Source,
      levels = c("Discovery", "Prospective", "Horne lab")
    )
  )

# Normalize data to AIUP. Pooled discovery, prospective. Separated Horne lab.
for(gene in gene_names){
  dci_mean <- mean(2^mdf[[gene]][
    (mdf$Source %in% c("Discovery", "Prospective")) & (mdf$Location == "AIUP")
  ])
  horne_mean <- mean(2^(mdf[[gene]][
    (mdf$Source == "Horne lab") & (mdf$Location == "AIUP")
  ]))
  mdf[[gene]][mdf$Source %in% c("Discovery", "Prospective")] <- 2^(
    mdf[[gene]][mdf$Source %in% c("Discovery", "Prospective")]
  )/dci_mean
  mdf[[gene]][mdf$Source == "Horne lab"] <- 2^(
    mdf[[gene]][mdf$Source == "Horne lab"]
  )/horne_mean
}

mdf <- tidyr::gather(mdf, "Gene", "Expression", -Location, -Sample, -Source) %>%
  dplyr::rename(Data = "Source", Type = "Location") %>%
  dplyr::mutate(Group = ifelse(Data == "Horne lab", "Horne lab", "DCI"))

# Calculate means.
df_means <- dplyr::group_by(mdf, Type, Data, Gene, Group) %>%
  dplyr::summarise(
    N = n(),
    SD = ifelse(N == 1, NA, sd(Expression)),
    se = ifelse(N == 1, 0, sd(Expression)/sqrt(N-1)),
    Expression = mean(Expression)
  ) %>%
  dplyr::ungroup()

p_tab <- SimplifyStats::pairwise_stats(
  mdf,
  group_cols = c("Gene", "Type"),
  var_cols = "Expression",
  fxn = wilcox.test,
  two_way = TRUE
) %>%
  dplyr::filter(
    A.Gene == B.Gene,
    A.Type == "AIUP"
  ) %>%
  dplyr::mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  dplyr::rename(Gene = "A.Gene") %>%
  dplyr::select(-Variable, -B.Gene)

plt <- ggplot(
  mdf,
  aes(Type, Expression, colour = Data)
)+
  # geom_boxplot()+
  ggbeeswarm::geom_quasirandom(dodge.width = 0.9)+
  geom_bar(
    data = df_means,
    mapping = aes(Type, Expression, fill = Data),
    alpha = 0.3,
    stat = "identity", position = "dodge"
  )+
  geom_errorbar(
    data = df_means,
    mapping = aes(
      ymin = Expression - se,
      ymax = Expression + se,
      group = Data
    ),
    position = position_dodge(width = 0.9),
    width = 0.2,
    colour = "black"
  )+
  coord_cartesian(ylim = c(0, 2.5), expand = FALSE)+
  ylab("Relative Expression")+
  theme(
    plot.margin = unit(c(0,1,0,0), "cm"),
    strip.background = element_blank(),
    axis.title.x = element_blank(),
    panel.spacing = unit(1, "lines")
  )+
  ylab("Relative Expression")+
  
  facet_wrap(~Gene, scales = "free", nrow = 3)+
  geom_signif(
    comparisons = list(c("AIUP", "ECT")),
    y_position = 1.9,
    annotation = "NS.",
    color = "black"
  )+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff", "#009933"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff", "#009933"))

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Housekeeping genes.tiff"),
  plt,
  base_height = 4, base_width = 5.5
)

# Display the plot.
plt
```


# Depict overall differential expression results
A volcano plot of the differential expression results was generated.
```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
all_dea <- readxl::read_excel(file.path("Results","All_DEA.xlsx"))

p_lower <- -log10(max(all_dea$P.Value[all_dea$adj.P.Val < 0.1]))

plt <- ggplot(
  
)+
  geom_point(
    data = dplyr::mutate(
      all_dea,
      `Differentially\nExpressed` = (abs(logFC) > 0.5) & 
        (-log10(P.Value) > p_lower)
    ),
    aes(logFC, -log10(P.Value), colour = `Differentially\nExpressed`)
  )+
  geom_hline(
    yintercept = p_lower,
    colour = "red", linetype = "dashed"
  )+
  geom_vline(xintercept = -0.5, colour = "blue", linetype = "dashed")+
  geom_vline(xintercept = 0.5, colour = "blue", linetype = "dashed")+
  coord_cartesian(xlim = c(-3,3), ylim = c(0,6), expand = FALSE)+
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf)+
  annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=-Inf, y=Inf, yend=Inf)+
  annotate("segment", x=Inf, xend=Inf, y=Inf, yend=-Inf)+
  xlab(bquote("log"[2]~("Fold Change")))+
  ylab(bquote("-log"[10]~("P Value")))+
  scale_colour_manual(values = c("gray", "black"))+
  theme(
    legend.position = "none"
  )

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Microarray_Volcano_Plot.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot
plt
```


# Statistical analysis of ROC curves


Confidence intervals for metrics related to the ROC curves were computed.


```{r message=FALSE, warning=FALSE}
# Create the curves.
roc_train <- pROC::roc(
  as.numeric(knn_predictions_train_roc$Location),
  knn_predictions_train_roc$Probability
)
roc_test <- pROC::roc(
  as.numeric(knn_predictions_test_roc$Location),
  knn_predictions_test_roc$Probability
)
roc_horne_train <- pROC::roc(
  as.numeric(roc_horne_train_df$Location),
  roc_horne_train_df$Probability
)
roc_horne <- pROC::roc(
  as.numeric(roc_horne_df$Location),
  roc_horne_df$Probability
)

# Calculate the difference between curves.
difference_between_curves <- tibble::data_frame(
  Curve_1 = c(
    "Discovery",
    "Discovery",
    "Discovery",
    
    "Prospective",
    "Prospective",
    
    "Horne lab - Train"
  ),
  Curve_2 = c(
    "Prospective",
    "Horne lab - Train",
    "Horne lab - Test",
    
    "Horne lab - Train",
    "Horne lab - Test",
    
    "Horne lab - Test"
  ),
  p.value = c(
    pROC::roc.test(
      roc_train, roc_test, method = "bootstrap", progress = "none"
    )$p.value,
    pROC::roc.test(
      roc_train, roc_horne_train, method = "bootstrap", progress = "none"
    )$p.value,
    pROC::roc.test(
      roc_train, roc_horne, method = "bootstrap", progress = "none"
    )$p.value,
    
    pROC::roc.test(
      roc_test, roc_horne_train, method = "bootstrap", progress = "none"
    )$p.value,
    pROC::roc.test(
      roc_test, roc_horne, method = "bootstrap", progress = "none"
    )$p.value,
    
    pROC::roc.test(
      roc_horne_train, roc_horne, method = "bootstrap", progress = "none"
    )$p.value
  )
)
writexl::write_xlsx(
  difference_between_curves,
  file.path("Results", "AUC_Differences.xlsx")
)

get_roc_data <- function(roc_obj, curve_name){
  # Calculate CIs.
  roc_obj_auc <- pROC::ci(
    roc_obj, of = "auc", method = "bootstrap", progress = "none"
  )
  roc_obj_spse <- pROC::ci.thresholds(
    roc_obj, thresholds = 0.5, progress = "none"
  )
  
  # Assemble output.
  auc_out <- tibble::data_frame(
    Curve = curve_name,
    AUC = roc_obj$auc,
    AUC_low = roc_obj_auc[1],
    AUC_high = roc_obj_auc[2],
    specificity = roc_obj_spse$specificity[2],
    specificity_low = roc_obj_spse$specificity[1],
    specificity_high = roc_obj_spse$specificity[3],
    sensitivity = roc_obj_spse$sensitivity[2],
    sensitivity_low = roc_obj_spse$sensitivity[1],
    sensitivity_high = roc_obj_spse$sensitivity[3]
  )
  
  # Return the output.
  return(auc_out)
}

roc_data <- dplyr::bind_rows(
  get_roc_data(roc_train, "Discovery"),
  get_roc_data(roc_test, "Prospective"),
  get_roc_data(roc_horne_train, "Horne lab - Train"),
  get_roc_data(roc_horne, "Horne lab - Test")
)

# Save the ROC data.
writexl::write_xlsx(
  roc_data,
  file.path("Results", "ROC_Data.xlsx")
)

# Display the metrics.
roc_data
```








End of Analysis.
