---
title: "Microarray_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



# Define paths


```{r}
# Path to the metadata file.
file_metadata <- file.path("Data", "metadata.xls")
```


# Prepare the environment


The directory was organized.


```{r message=FALSE, warning=FALSE}
create_folder <- function(folder_name){
  if(dir.exists(folder_name)){
    unlink(folder_name, recursive = TRUE, force = TRUE)
  }
  dir.create(folder_name)
}

create_folder("Cache")
create_folder("Results")
```


Key packages were loaded.


```{r message=FALSE, warning=FALSE}
library(magrittr) # Pipe operator (%>%).
library(ggplot2) # Plotting.
library(cowplot) # Plotting.
theme_set(theme_cowplot())
```


# Load the data


The metadata was loaded.


```{r message=FALSE, warning=FALSE}
metadata <- readxl::read_excel(file_metadata) %>%
  dplyr::mutate(
    Data_Source = factor(Data_Source, levels = c("Internal", "External")),
    Group = factor(Group, levels = c("AIUP", "ECT"))
  )
```


The internal dataset was loaded.


```{r message=FALSE, warning=FALSE}
internal_metadata <- dplyr::filter(metadata, Data_Source == "Internal")
internal_features <- Biobase::AnnotatedDataFrame(
  readr::read_csv(
    internal_metadata$Annotation_file[1],
    skip = internal_metadata$Annotation_file_skip_lines[1]
  ) %>%
    dplyr::select(probeset_id) %>%
    as.data.frame() %>%
    dplyr::mutate(TEMP = probeset_id) %>%
    tibble::column_to_rownames("TEMP")
)
internal_raw <- oligo::read.celfiles( # Read CEL files.
  filenames = internal_metadata$Path, # CEL files to load.
  phenoData = Biobase::AnnotatedDataFrame( # Their metadata.
    internal_metadata %>%
      as.data.frame() %>%
      dplyr::mutate(TEMP = Unique_ID) %>%
      tibble::column_to_rownames("TEMP")
  )
) %>%
  oligo::rma( # Perform RMA.
    ., 
    background = TRUE,
    normalize = TRUE,
    target = "core"
  ) %>%
  affycoretools::getMainProbes()
internal_features <- internal_features[Biobase::featureNames(internal_raw)]
Biobase::featureData(internal_raw) <- internal_features
# Retrieve feature annotations.
library(hugene20sttranscriptcluster.db)
internal_genes <- AnnotationDbi::select(
  hugene20sttranscriptcluster.db,
  Biobase::featureNames(internal_raw),
  c("ENSEMBL", "ENSEMBLTRANS", "SYMBOL", "GENENAME")
)
internal_genes <- internal_genes[!duplicated(internal_genes$PROBEID),]
rownames(internal_genes) <- internal_genes$PROBEID
internal_genes <- internal_genes[Biobase::featureNames(internal_raw),]
Biobase::featureData(internal_raw) <- Biobase::AnnotatedDataFrame(
  internal_genes
)
internal_raw <- internal_raw[!is.na(internal_genes$SYMBOL)]
```


The external dataset was loaded.


```{r message=FALSE, warning=FALSE}
external_metadata <- dplyr::filter(metadata, Data_Source == "External")
external_features <- Biobase::AnnotatedDataFrame(
  readr::read_tsv(
    external_metadata$Annotation_file[1],
    skip = external_metadata$Annotation_file_skip_lines[1]
  ) %>%
    as.data.frame() %>%
    dplyr::mutate(TEMP = `Composite Element Name`) %>%
    tibble::column_to_rownames("TEMP")
)
external_features <- Biobase::AnnotatedDataFrame(
  external_features@data[
    external_features@data$`Composite Element Database Entry[ensembl]` %in% 
      internal_raw@featureData@data$ENSEMBL,
  ] %>%
    as.data.frame() %>%
    dplyr::mutate(TEMP = `Composite Element Name`) %>%
    tibble::column_to_rownames("TEMP")
)
external_pheno <- Biobase::AnnotatedDataFrame( # Their metadata.
  external_metadata %>%
    as.data.frame() %>%
    dplyr::mutate(TEMP = Unique_ID) %>%
    tibble::column_to_rownames("TEMP")
)
external_raw <- affy::rma(
    object = affy::ReadAffy(filenames = external_metadata$Path),
    phenoData = external_pheno,
    verbose = FALSE,
    background = TRUE,
    normalize = TRUE,
    subset = external_features@data$`Composite Element Name`
  )
Biobase::phenoData(external_raw) <- external_pheno
external_features <- external_features[Biobase::featureNames(external_raw)]
Biobase::featureData(external_raw) <- external_features
# Retrieve feature annotations.
library(hgu133plus2.db)
external_genes <- AnnotationDbi::select(
  hgu133plus2.db,
  Biobase::featureNames(external_raw),
  c("ENSEMBL", "ENSEMBLTRANS", "SYMBOL", "GENENAME")
)
external_genes <- external_genes[!duplicated(external_genes$PROBEID),]
rownames(external_genes) <- external_genes$PROBEID
external_genes <- external_genes[Biobase::featureNames(external_raw),]
Biobase::featureData(external_raw) <- Biobase::AnnotatedDataFrame(
  external_genes
)
external_raw <- external_raw[!is.na(external_genes$SYMBOL)]
Biobase::sampleNames(external_raw) <- external_metadata$Unique_ID
```


# Explore the normalized data


Normalized data were plotted for the internal data.


```{r message=FALSE, warning=FALSE}
plt <- ggplotify::as.ggplot(
  ~hist(
    internal_raw,
    xlim = c(0,16), ylim = c(0, 0.31),
    xaxs="i", yaxs="i",
    xlab = bquote("log"[2]~"Intensity"), ylab = "Probability Density"
  )
)

cowplot::save_plot(
  file.path("Results", "Normalized_Internal.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

plt
```


Normalized data were plotted for the external data.


```{r message=FALSE, warning=FALSE}
plt <- ggplotify::as.ggplot(
  ~hist(
    external_raw,
    xlim = c(0,16), ylim = c(0, 0.31),
    xaxs="i", yaxs="i",
    xlab = bquote("log"[2]~"Intensity"), ylab = "Probability Density"
  )
)

cowplot::save_plot(
  file.path("Results", "Normalized_External.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

plt
```



# Differential expression analysis


```{r}
# Specify the groups.
dinternal_raw <- internal_raw[,is.na(Biobase::pData(internal_raw)$Replicate_ID)]
exp_design <- model.matrix(~Biobase::pData(dinternal_raw)$Group)
colnames(exp_design) <- c("(Intercept)", "ECT")
attr(exp_design, "contrasts") <- "location"

# Perform differential expression analysis.
fit <- limma::lmFit(dinternal_raw, exp_design)
efit <- limma::eBayes(fit)

# Extract all DEGs.
degs <- limma::topTable(
  efit,
  coef = "ECT",
  number = Inf,
  p.value = Inf,
  lfc = 0
) %>%
  tibble::as_tibble()
writexl::write_xlsx(
  degs,
  file.path("Results", "DEGs_All.xlsx")
)

# Subset the top DEGs.
top_degs <- limma::topTable(
  efit,
  coef = "ECT",
  number = Inf,
  p.value = 0.05,
  lfc = 0.5
) %>%
  tibble::as_tibble()
writexl::write_xlsx(
  top_degs,
  file.path("Results", "DEGs_Top.xlsx")
)
```


# Feature selection


Gene ontology analysis was performed.


```{r message=FALSE, warning=FALSE}
# Define the DEGs and genes in the universe.
deg_ensembl <- unique(top_degs$ENSEMBL)
deg_ensembl <- deg_ensembl[!is.na(deg_ensembl)]
deg_entrez <- AnnotationDbi::mapIds(
  org.Hs.eg.db,
  keys = deg_ensembl,
  column = "ENTREZID",
  keytype = "ENSEMBL",
  multiVals = "first"
)
all_ensembl <- unique(degs$ENSEMBL)
all_ensembl <- all_ensembl[!is.na(all_ensembl)]
universe_entrez <- AnnotationDbi::mapIds(
  org.Hs.eg.db,
  keys = all_ensembl,
  column = "ENTREZID",
  keytype = "ENSEMBL",
  multiVals = "first"
)
go_results_bp <- clusterProfiler::enrichGO(
  gene = deg_entrez,
  universe = universe_entrez,
  OrgDb = "org.Hs.eg.db",
  keyType = "ENTREZID",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.1,
  qvalueCutoff = 0.1,
  minGSSize = 5,
  maxGSSize = 500
)
writexl::write_xlsx(
  as.data.frame(go_results_bp) %>% dplyr::filter(Count >= 5),
  file.path("Results","GO_Results_BP.xlsx")
)
go_results_cc <- clusterProfiler::enrichGO(
  gene = deg_entrez,
  universe = universe_entrez,
  OrgDb = "org.Hs.eg.db",
  keyType = "ENTREZID",
  ont = "CC",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.1,
  qvalueCutoff = 0.1,
  minGSSize = 5,
  maxGSSize = 500
)
writexl::write_xlsx(
  as.data.frame(go_results_cc) %>% dplyr::filter(Count >= 5),
  file.path("Results","GO_Results_CC.xlsx")
)
go_results_mf <- clusterProfiler::enrichGO(
  gene = deg_entrez,
  universe = universe_entrez,
  OrgDb = "org.Hs.eg.db",
  keyType = "ENTREZID",
  ont = "MF",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.1,
  qvalueCutoff = 0.1,
  minGSSize = 5,
  maxGSSize = 500
)
writexl::write_xlsx(
  as.data.frame(go_results_mf) %>% dplyr::filter(Count >= 5),
  file.path("Results","GO_Results_MF.xlsx")
)
```


```{r message=FALSE, warning=FALSE}
logFC_requirement <- 0.8

# Cilia-related GO terms.
cilia_go <- c(
  go_results_bp$ID[grepl("cilium|cilia", go_results_bp$Description)],
  go_results_cc$ID[grepl("cilium|cilia", go_results_cc$Description)],
  go_results_mf$ID[grepl("cilium|cilia", go_results_mf$Description)]
) %>%
  unique()

# Get cilia-related genes.
cilia_ensembl <- (AnnotationDbi::select(
  org.Hs.eg.db,
  keys = deg_entrez,
  column = c("ENSEMBL", "GO"),
  keytypes = "ENTREZID"
) %>%
  tidyr::drop_na() %>%
  tibble::as_tibble() %>%
  dplyr::select(ENSEMBL, GO) %>%
  dplyr::filter(GO %in% cilia_go))$ENSEMBL %>%
  unique() %>% sort()

# Load additional cilia-related genes identified by the Sergeeva lab.
sergeeva_path <- file.path(
  "Data", "Reference", "Sergeeva_Lab", "journal.pone.0035618.s010.XLS"
)
sergeeva_genes <- (readxl::read_excel(sergeeva_path) %>%
                  tidyr::drop_na())$Symbol
cilia_ensembl <- c(
  cilia_ensembl,
  top_degs[top_degs$SYMBOL %in% sergeeva_genes,]$ENSEMBL %>% unique()
) %>%
  unique()

degs$CILIA <- FALSE
degs$CILIA[degs$ENSEMBL %in% cilia_ensembl] <- TRUE

cilia_degs <- degs[degs$CILIA,] %>%
  dplyr::filter(
    adj.P.Val < 0.01,
    abs(logFC) > logFC_requirement
  )
cilia_ensembl <- cilia_degs$ENSEMBL %>% unique()

# Save the cilia-related genes.
writexl::write_xlsx(
  cilia_degs,
  file.path("Results", "DEGs_Cilia.xlsx")
)
```


A volcano plot of the differential expression results was generated.


```{r message=FALSE, warning=FALSE, fig.width=6.5, fig.height=4}
p_lower <- -log10(0.05)
pvals <- c(0.5, 0.1, 0.05, 0.01, 0.001)
plt <- ggplot()+
  geom_point(
    data = dplyr::mutate(
      degs,
      `Differentially\nExpressed` = (abs(logFC) > 0.5) & 
        (-log10(adj.P.Val) > p_lower)
    ),
    aes(logFC, -log10(adj.P.Val), colour = `Differentially\nExpressed`)
  )+
  geom_point(
    data = dplyr::mutate(
      cilia_degs,
      `Differentially\nExpressed` = (abs(logFC) > 0.5) & 
        (-log10(adj.P.Val) > -log10(0.01))
    ),
    aes(logFC, -log10(adj.P.Val)),
    colour = "red"
  )+
  geom_hline(
    yintercept = p_lower,
    colour = "red", linetype = "dashed"
  )+
  geom_vline(xintercept = -0.5, colour = "blue", linetype = "dashed")+
  geom_vline(xintercept = 0.5, colour = "blue", linetype = "dashed")+
  coord_cartesian(
    xlim = c(-3,3),
    ylim = c(0,-log10(tail(pvals,1))),
    expand = FALSE
  )+
  panel_border(colour = "black", size = 1.2)+
  xlab(bquote("log"[2]~("Fold Change")))+
  ylab("FDR")+
  scale_colour_manual(values = c("gray", "black"))+
  theme(
    legend.position = "none"
  )+
  scale_y_continuous(
    breaks = -log10(pvals),
    labels = pvals
  )

# Save the plot.
cowplot::save_plot(
  file.path("Results", "Microarray_Volcano_Plot.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Display the plot
plt
```


The expression level of the classifier genes were organized into structures more amenable to data analysis.


```{r}
internal_all_exprs <- Biobase::exprs(internal_raw)[cilia_degs$PROBEID,] %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Unique_ID") %>%
  dplyr::mutate(
    Unique_ID = Biobase::pData(internal_raw)$Unique_ID,
    Group = Biobase::pData(internal_raw)$Group,
    PUL = Biobase::pData(internal_raw)$PUL,
    Replicate_ID = Biobase::pData(internal_raw)$Replicate_ID
  ) %>%
  tidyr::gather(
    key = "PROBEID",
    value = "Expression",
    -Unique_ID, -Group, -PUL, -Replicate_ID
  ) %>%
  dplyr::mutate(
    ENSEMBL = (cilia_degs[,c("PROBEID","ENSEMBL")] %>%
                 tibble::deframe())[PROBEID],
    SYMBOL = (cilia_degs[,c("PROBEID","SYMBOL")] %>%
                 tibble::deframe())[PROBEID]
  )
internal_spread <- tidyr::spread(
  internal_all_exprs[,c("Unique_ID","SYMBOL","Expression")],
  SYMBOL, Expression
) %>%
  dplyr::select(-Unique_ID) %>%
  dplyr::mutate(Group = Biobase::pData(internal_raw)$Group)

external_all_exprs <- Biobase::exprs(external_raw)[(
  Biobase::featureData(external_raw)$PROBEID[
    (Biobase::featureData(external_raw)$ENSEMBL %in% cilia_ensembl) & 
      !duplicated(Biobase::featureData(external_raw)$ENSEMBL)
  ]
),] %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Unique_ID") %>%
  dplyr::mutate(
    Unique_ID = Biobase::pData(external_raw)$Unique_ID,
    Group = Biobase::pData(external_raw)$Group,
    PUL = Biobase::pData(external_raw)$PUL,
    Replicate_ID = Biobase::pData(external_raw)$Replicate_ID
  ) %>%
  tidyr::gather(
    key = "PROBEID",
    value = "Expression",
    -Unique_ID, -Group, -PUL, -Replicate_ID
  ) %>%
  dplyr::mutate(
    ENSEMBL = (Biobase::featureData(
      external_raw
    )@data[,c("PROBEID","ENSEMBL")] %>% tibble::deframe())[PROBEID],
    SYMBOL = (Biobase::featureData(
      external_raw
    )@data[,c("PROBEID","SYMBOL")] %>% tibble::deframe())[PROBEID]
  )
external_spread <- tidyr::spread(
  external_all_exprs[,c("Unique_ID","SYMBOL","Expression")],
  SYMBOL, Expression
) %>%
  dplyr::select(-Unique_ID) %>%
  dplyr::mutate(Group = Biobase::pData(external_raw)$Group)



# Stack both datasets.
expr_stacked <- dplyr::bind_rows(
  dplyr::mutate(internal_all_exprs, Data_Source = "Internal"),
  dplyr::mutate(external_all_exprs, Data_Source = "External")
) %>%
  dplyr::mutate(
    SYMBOL = factor(SYMBOL),
    Data_Source = factor(Data_Source, levels = c("Internal", "External"))
  )
norms <- dplyr::filter(expr_stacked, Group == "AIUP", is.na(Replicate_ID)) %>%
  dplyr::group_by(SYMBOL, Data_Source) %>%
  dplyr::summarise(MEAN = mean(Expression)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(TEMP = paste(Data_Source, SYMBOL)) %>%
  dplyr::select(TEMP, MEAN) %>%
  tibble::deframe()
norms_stacked <- dplyr::mutate(
  expr_stacked,
  TEMP = paste(Data_Source, SYMBOL),
  Expression = Expression - norms[TEMP]
) %>%
  dplyr::select(-TEMP)
```



A heatmap was generated.


```{r}
internal_heat_exprs <- Biobase::exprs(internal_raw)[
  top_degs$PROBEID[!duplicated(top_degs$SYMBOL)],
] %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Unique_ID") %>%
  dplyr::mutate(
    Sample = Biobase::pData(internal_raw)$Sample,
    Group = Biobase::pData(internal_raw)$Group,
    Replicate_ID = Biobase::pData(internal_raw)$Replicate_ID
  ) %>%
  dplyr::filter(is.na(Replicate_ID)) %>%
  dplyr::select(-Replicate_ID, -Unique_ID)
internal_heat_samples <- internal_heat_exprs$Sample
internal_heat_groups <- internal_heat_exprs$Group
internal_heat_exprs <- dplyr::select(
  internal_heat_exprs,
  -Sample, -Group
)
internal_heat_genes <- top_degs$SYMBOL[!duplicated(top_degs$SYMBOL)]

rownames(internal_heat_exprs) <- internal_heat_samples
colnames(internal_heat_exprs) <- internal_heat_genes

# predd <- as.dendrogram(clustered)
hclustAvg <- hclustAvg <- function(x){hclust(x, method = "complete")}

# Create a tiff.
plot.new()
tiff(
  filename = file.path("Results","Internal_heatmap.tiff"),
  width = 6.5, height = 9, unit = "in",
  pointsize = 12, res = 300
)

gplots::heatmap.2(
  as.matrix(internal_heat_exprs) %>% t(),
  distfun = dist,
  # Colv = predd,
  Rowv = TRUE,
  labRow = as.character(internal_heat_genes),
  ColSideColors = ifelse(as.character(internal_heat_groups) == "AIUP", "#ff4d4d", "#0099ff"),
  hclustfun = hclustAvg,
  trace = "none",
  col = gplots::colorpanel(100, "blue", "white", "red"),
  #dendrogram = "column",
  scale = "row",
  margins = c(0.5,6.5), #column and row name spacing
  density.info = "none",
  key.title = "Expression",
  #adjCol = c( 1, 0 )
  #lmat = rbind( c( 0, 4 ), c( 0, 1 ), c( 3, 2 ) ),
  #lhei = c( lcm( 2 ) , lcm( 2 ), lcm( 2 ) ),
  # lwid = c( 1, 6 ),
  keysize = 0.8,
  #key.par = list( cex=0.7 )
  key.xtickfun = function(x){return(list(
    at = seq(0,1,0.5),
    labels = as.character(c(-3,0,3))
  ))},
  key.xlab = "Expression\nZ score"
)

legend(
  x = -0.09, y = 0.925,
  legend = levels(internal_heat_groups),
  #lty= 1,
  #lwd = 2,
  bty = "n",
  fill = c("#ff4d4d", "#0099ff"),
  cex=.8,
  xpd = T,
)
dev.off()
graphics.off()

# Create a png.
plot.new()
png(
  filename = file.path("Results","Internal_heatmap.png"),
  width = 6.5, height = 9, unit = "in",
  pointsize = 12, res = 300
)

gplots::heatmap.2(
  as.matrix(internal_heat_exprs) %>% t(),
  distfun = dist,
  # Colv = predd,
  Rowv = TRUE,
  labRow = as.character(internal_heat_genes),
  ColSideColors = ifelse(as.character(internal_heat_groups) == "AIUP", "#ff4d4d", "#0099ff"),
  hclustfun = hclustAvg,
  trace = "none",
  col = gplots::colorpanel(100, "blue", "white", "red"),
  #dendrogram = "column",
  scale = "row",
  margins = c(0.5,6.5), #column and row name spacing
  density.info = "none",
  key.title = "Expression",
  #adjCol = c( 1, 0 )
  #lmat = rbind( c( 0, 4 ), c( 0, 1 ), c( 3, 2 ) ),
  #lhei = c( lcm( 2 ) , lcm( 2 ), lcm( 2 ) ),
  # lwid = c( 1, 6 ),
  keysize = 0.8,
  #key.par = list( cex=0.7 )
  key.xtickfun = function(x){return(list(
    at = seq(0,1,0.5),
    labels = as.character(c(-3,0,3))
  ))},
  key.xlab = "Expression\nZ score"
)

legend(
  x = -0.09, y = 0.925,
  legend = levels(internal_heat_groups),
  #lty= 1,
  #lwd = 2,
  bty = "n",
  fill = c("#ff4d4d", "#0099ff"),
  cex=.8,
  xpd = T,
)
dev.off()
graphics.off()
```


The potential for GUSB, PGK1, and RPL19 to serve as loading controls for qPCR and nCounter experiments was evaluated using the microarray data.


```{r}
linternal_all_exprs <- Biobase::exprs(internal_raw) %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Unique_ID") %>%
  dplyr::mutate(
    Unique_ID = Biobase::pData(internal_raw)$Unique_ID,
    Group = Biobase::pData(internal_raw)$Group,
    PUL = Biobase::pData(internal_raw)$PUL,
    Replicate_ID = Biobase::pData(internal_raw)$Replicate_ID
  ) %>%
  tidyr::gather(
    key = "PROBEID",
    value = "Expression",
    -Unique_ID, -Group, -PUL, -Replicate_ID
  ) %>%
  dplyr::mutate(
    ENSEMBL = (degs[,c("PROBEID","ENSEMBL")] %>%
                 tibble::deframe())[PROBEID],
    SYMBOL = (degs[,c("PROBEID","SYMBOL")] %>%
                 tibble::deframe())[PROBEID]
  ) %>%
  tibble::as_tibble() %>%
  dplyr::filter(
    SYMBOL %in% c("GUSB", "PGK1", "RPL19"),
    is.na(Replicate_ID)
  ) %>%
  dplyr::select(-PUL, -PROBEID, -Replicate_ID) %>%
  dplyr::mutate(group_gene = paste(Group, SYMBOL))
linternal_norms <- dplyr::filter(linternal_all_exprs, Group == "AIUP") %>%
  dplyr::group_by(SYMBOL) %>%
  dplyr::summarise(MEAN = mean(Expression)) %>%
  dplyr::ungroup() %>%
  tibble::deframe()
linternal_norm <- dplyr::mutate(
  linternal_all_exprs,
  NORM = Expression - linternal_norms[SYMBOL]
)

lexternal_all_exprs <- Biobase::exprs(external_raw) %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Unique_ID") %>%
  dplyr::mutate(
    Unique_ID = Biobase::pData(external_raw)$Unique_ID,
    Group = Biobase::pData(external_raw)$Group,
    PUL = Biobase::pData(external_raw)$PUL,
    Replicate_ID = Biobase::pData(external_raw)$Replicate_ID
  ) %>%
  tidyr::gather(
    key = "PROBEID",
    value = "Expression",
    -Unique_ID, -Group, -PUL, -Replicate_ID
  ) %>%
  dplyr::mutate(
    SYMBOL = (Biobase::featureData(
      external_raw
    )@data[,c("PROBEID","SYMBOL")] %>% tibble::deframe())[PROBEID]
  ) %>%
  tibble::as_tibble() %>%
  dplyr::filter(
    SYMBOL %in% c("GUSB", "PGK1", "RPL19"),
    is.na(Replicate_ID)
  ) %>%
  dplyr::select(-PUL, -PROBEID, -Replicate_ID) %>%
  dplyr::mutate(group_gene = paste(Group, SYMBOL))
lexternal_norms <- dplyr::filter(lexternal_all_exprs, Group == "AIUP") %>%
  dplyr::group_by(SYMBOL) %>%
  dplyr::summarise(MEAN = mean(Expression)) %>%
  dplyr::ungroup() %>%
  tibble::deframe()
lexternal_norm <- dplyr::mutate(
  lexternal_all_exprs,
  NORM = Expression - lexternal_norms[SYMBOL]
)



lstacked <- dplyr::bind_rows(
  dplyr::mutate(linternal_norm, Data = "Internal"),
  dplyr::mutate(lexternal_norm, Data = "External")
) %>%
  dplyr::mutate(
    Data = factor(Data, levels = c("Internal", "External")),
    SYMBOL = factor(SYMBOL)
  ) %>%
  dplyr::select(-group_gene)
lstacked_summarized <- SimplifyStats::group_summarize(
  lstacked,
  group_cols = c("Group", "SYMBOL", "Data"),
  var_cols = "NORM"
)
lstacked_tests <- SimplifyStats::pairwise_stats(
  lstacked,
  group_cols = c("Group", "SYMBOL", "Data"),
  var_cols = "NORM",
  wilcox.test,
  two_way = TRUE
) %>%
  dplyr::filter(
    A.Group == "AIUP", B.Group == "ECT",
    A.SYMBOL == B.SYMBOL,
    A.Data == B.Data
  ) %>%
  dplyr::rename(
    SYMBOL = "A.SYMBOL",
    Data = "A.Data"
  ) %>%
  dplyr::select(-A.Group, -B.Group, -B.SYMBOL, -B.Data)

writexl::write_xlsx(
  lstacked_tests,
  file.path("Results", "Housekeeping_Genes.xlsx")
)
```


The expression level of the classifier genes were evaluated using non-parametric tests.


```{r}
# Calculate descriptive statistics.
norms_summarized <- SimplifyStats::group_summarize(
  dplyr::filter(norms_stacked, is.na(Replicate_ID)),
  group_cols = c("Data_Source", "Group", "SYMBOL"),
  var_cols = "Expression"
)

# Perform non-parametric tests.
norms_wilcox <- SimplifyStats::pairwise_stats(
  norms_stacked,
  group_cols = c("Data_Source", "Group", "SYMBOL"),
  var_cols = "Expression",
  fxn = wilcox.test
) %>%
  dplyr::filter(
    A.Group == "AIUP", B.Group == "ECT",
    A.SYMBOL == B.SYMBOL,
    A.Data_Source == B.Data_Source
  ) %>%
  dplyr::rename(
    SYMBOL = "A.SYMBOL",
    Data_Source = "A.Data_Source"
  ) %>%
  dplyr::select(-B.SYMBOL, -B.Data_Source)

writexl::write_xlsx(norms_wilcox, file.path("Results", "DEGs_Wilcox.xlsx"))
```


The expression levels for the classifier genes were plotted.


```{r}
plt <- ggplot()+
  geom_col(
    data = norms_summarized,
    mapping = aes(Data_Source, Mean, fill = Group, group = Group),
    alpha = 0.2,
    position = "dodge"
  )+
  geom_hline(yintercept = 0, colour = "#009933", size = 1.2)+
  ggbeeswarm::geom_quasirandom(
    data = dplyr::filter(norms_stacked, is.na(Replicate_ID)),
    mapping = aes(Data_Source, Expression, colour = Group, group = Group),
    dodge.width = 0.9
  )+
  geom_errorbar(
    data = norms_summarized,
    mapping = aes(
      x = Data_Source,
      ymin = Mean - StdErr,
      ymax = Mean + StdErr,
      group = Group
    ),
    position = position_dodge(0.9), width = 0.2
  )+
  ylab(bquote("log"[2]~"Fold Change"))+
  xlab("Data Source")+
  panel_border(colour = "black", size = 1.2)+
  theme(
    strip.background = element_blank(),
    strip.text = element_text(face = "italic"),
    axis.text.x = element_text(size = 11)
  )+
  scale_fill_manual(values = c("#ff4d4d", "#0099ff"))+
  scale_colour_manual(values = c("#ff4d4d", "#0099ff"))+
  labs(fill = "Location", colour = "Location")+
  geom_text(
    data = norms_wilcox,
    mapping = aes(
      Data_Source, 3.5,
      label = signif(p.value, 1) %>%
        as.character() %>%
        paste0("italic('p=')*", .),
      colour = NULL, group = NULL
    ),
    inherit.aes = FALSE,
    show.legend = FALSE,
    parse = TRUE, size = 3
  )+
  facet_wrap(~SYMBOL, scales = "free")+
  coord_cartesian(ylim = c(-1,4))+
  scale_y_continuous(
    expand = expand_scale(
      mult = c(0,0),
      add = c(0,0)
    )
  )

cowplot::save_plot(
  file.path("Results", "Gene_Expression.tiff"),
  plt,
  base_width = 6.5, base_height = 5.5
)
```

Save the normalized data.


```{r}
norm_data <- dplyr::filter(
  norms_stacked,
  is.na(Replicate_ID),
  Data_Source == "Internal"
) %>%
  dplyr::select(
    -PUL, -Replicate_ID, -PROBEID, -ENSEMBL, -Data_Source
  ) %>%
  dplyr::inner_join(
    ., Biobase::pData(dinternal_raw)[,c("Unique_ID","Sample")] %>%
    dplyr::mutate(Sample = gsub("MP","PUL_",Sample)),
    by = "Unique_ID"
  ) %>%
  dplyr::select(-Unique_ID) %>%
  dplyr::rename(
    Label = "Group",
    Gene = "SYMBOL"
  ) %>%
  dplyr::mutate(
    Source = "Microarray",
    Expression = 2^Expression
  )
writexl::write_xlsx(
  norm_data,
  file.path("Results", "Microarray_Normalized_Data.xlsx")
)
```


```{r}
norm_data_external <- dplyr::filter(
  norms_stacked,
  is.na(Replicate_ID),
  Data_Source == "External"
) %>%
  dplyr::select(
    -PUL, -Replicate_ID, -PROBEID, -ENSEMBL, -Data_Source
  ) %>%
  dplyr::inner_join(
    ., Biobase::pData(external_raw)[,c("Unique_ID","Sample")],
    by = "Unique_ID"
  ) %>%
  dplyr::select(-Unique_ID) %>%
  dplyr::rename(
    Label = "Group",
    Gene = "SYMBOL"
  ) %>%
  dplyr::mutate(
    Source = "Microarray",
    Expression = 2^Expression
  )
writexl::write_xlsx(
  norm_data_external,
  file.path("Results", "Microarray_Normalized_Data_External.xlsx")
)
```


# Model development


```{r}
# Perform loocv to identify the optimal lambda.
ln_lambdas_tried <- seq(-10, 10, 0.01)
cv_a_glmnet <- function(current_spread, ln_lambdas_tried){
  glmnet::cv.glmnet(
    x = current_spread %>%
      dplyr::select(-Group) %>%
      as.matrix(),
    y = current_spread$Group,
    family = "binomial",
    alpha = 0,
    lambda = exp(ln_lambdas_tried),
    nfolds = nrow(current_spread),
    grouped = FALSE
  )
}
internal_cv_glmnet <- cv_a_glmnet(internal_spread, ln_lambdas_tried)
external_cv_glmnet <- cv_a_glmnet(external_spread, ln_lambdas_tried)

# Generate a PCA scatterplot.
plot_pca_scatter <- function(df){
  cols_to_exclude <- "Group"
  df_wo_groups <- df[,!(colnames(df) %in% cols_to_exclude)]
  pca <- FactoMineR::PCA(
    df_wo_groups, ncp = ncol(df_wo_groups), graph = FALSE, scale.unit = FALSE
  )
  df_plt <- tibble::tibble(
    Group = df$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  ggplot()+
    coord_fixed()+
    scale_x_continuous(expand = expand_scale(mult = 0.1, add = 0))+
    scale_y_continuous(expand = expand_scale(mult = 0.1, add = 0))+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    theme(
      legend.title = element_blank()
    )+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )
}

plt <- plot_pca_scatter(internal_spread)
cowplot::save_plot(
  file.path("Results", "Internal_PCA.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_pca_scatter(external_spread)
cowplot::save_plot(
  file.path("Results", "External_PCA.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a scree plot.
plot_pca_scree <- function(df){
  cols_to_exclude <- "Group"
  df_wo_groups <- df[,!(colnames(df) %in% cols_to_exclude)]
  pca <- FactoMineR::PCA(
    df_wo_groups, ncp = ncol(df_wo_groups), graph = FALSE, scale.unit = FALSE
  )
  df_plt <- as.data.frame(pca$eig) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(PC = factor(dplyr::row_number()))
  
  ggplot()+
    coord_cartesian(ylim = c(0,100))+
    scale_y_continuous(expand = expand_scale(mult = 0, add = 0))+
    geom_line(
      data = df_plt,
      mapping = aes(PC, `percentage of variance`, group = 1),
      colour = "red"
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC, `percentage of variance`),
      colour = "black", size = 1.2
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab("PC")+ylab("Variance explained (%)")
}

plt <- plot_pca_scree(internal_spread)
cowplot::save_plot(
  file.path("Results", "Internal_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_pca_scree(external_spread)
cowplot::save_plot(
  file.path("Results", "External_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot the cross validation results.
plot_cv_glmnet <- function(current_cv, ln_lambdas_tried){
  df <- tibble::tibble(
    `ln(lambda)` = rev(ln_lambdas_tried),
    lambda = current_cv$lambda,
    cvm = current_cv$cvm,
    cvlo = current_cv$cvlo,
    cvup = current_cv$cvup
  )
  upper_bound <- 1.2*max(df$cvup)
  
  ggplot()+
  geom_line(
    data = df,
    mapping = aes(`ln(lambda)`, cvm),
    colour = "red", size = 1.2
  )+
  geom_line(
    data = df,
    mapping = aes(`ln(lambda)`, cvlo),
    linetype = "dashed", colour = "black", alpha = 0.8, size = 0.6
  )+
  geom_line(
    data = df,
    mapping = aes(`ln(lambda)`, cvup),
    linetype = "dashed", colour = "black", alpha = 0.8, size = 0.6
  )+
  geom_ribbon(
    data = df,
    mapping = aes(
      x = `ln(lambda)`,
      ymin = cvlo, ymax = cvup
    ),
    fill = "gray", alpha = 0.2,
  )+
  geom_vline(
    xintercept = log(current_cv$lambda.min),
    colour = "#0099ff", size = 0.8, linetype = "dashed"
  )+
  coord_cartesian(ylim = c(0,upper_bound))+
  scale_x_continuous(expand = expand_scale(mult = c(0,0), add = c(0,0)))+
  scale_y_continuous(expand = expand_scale(mult = c(0,0.15), add = c(0,0)))+
  panel_border(colour = "black", size = 1.2)+
  xlab("ln(lambda)")+ylab("Binomial Deviance")
}

plt <- plot_cv_glmnet(internal_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Internal_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_cv_glmnet(external_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "External_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Extract and save lambda values.
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = internal_cv_glmnet$lambda.min,
    labmda_1se = internal_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Internal_Lambda.xlsx")
)
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = external_cv_glmnet$lambda.min,
    labmda_1se = external_cv_glmnet$lambda.1se
  ),
  file.path("Results", "External_Lambda.xlsx")
)
```


Models were fit using the optimal lambdas.


```{r}
# Make predictions using loocv.
loocv_predictor <- function(df, cv){
  probs <- lapply(
    1:nrow(df),
    function(i){
      df_wo_i <- df[-i,] %>%
        dplyr::select(-Group) %>%
        as.matrix()
      df_i <- df[i,] %>%
        dplyr::select(-Group) %>%
        as.matrix()
      fit_internal <- glmnet::glmnet(
        x = df_wo_i,
        y = df$Group[-i],
        family = "binomial",
        alpha = 0,
        lambda = cv$lambda.min
      )
      prob <- predict(
        fit_internal,
        newx = df_i,
        type = "response"
      ) %>% as.vector()
    }
  ) %>% unlist()
  dplyr::mutate(
    df,
    Probability = probs
  ) %>%
    tibble::as_tibble()
}
internal_predictions <- loocv_predictor(internal_spread, internal_cv_glmnet)
external_predictions <- loocv_predictor(external_spread, external_cv_glmnet)

# Create an roc prediction object for further processing.
create_roc <- function(df){
  ROCR::prediction(
    predictions = df$Probability,
    labels = as.numeric(df$Group) - 1
  )
}
internal_rocr_prediction <- create_roc(internal_predictions)
external_rocr_prediction <- create_roc(external_predictions)

# Create an roc performance object for further processing.
create_performance <- function(rocr_prediction){
  ROCR::performance(rocr_prediction, measure = "mat")
}
internal_rocr_performance <- create_performance(internal_rocr_prediction)
external_rocr_performance <- create_performance(external_rocr_prediction)

# Determine the threshold that maximizes Mathhew's correlation coefficient
# (MCC).
get_threshold <- function(rocr_performance){
  which_max <- which.max(rocr_performance@y.values[[1]])
  tibble::tibble(
    Threshold = rocr_performance@x.values[[1]][which_max],
    MCC = rocr_performance@y.values[[1]][which_max]
  )
}
internal_rocr_threshold <- get_threshold(internal_rocr_performance)
external_rocr_threshold <- get_threshold(external_rocr_performance)

writexl::write_xlsx(
  internal_rocr_threshold,
  file.path("Results", "Internal_Threshold.xlsx")
)
writexl::write_xlsx(
  external_rocr_threshold,
  file.path("Results", "External_Threshold.xlsx")
)

# Use the threshold determined above to label the prediction based on their
# predicted probabilities.
label_predictions <- function(df, rocr_threshold){
  threshold <- rocr_threshold$Threshold
  dplyr::mutate(
    df,
    Prediction = ifelse(Probability < threshold, "AIUP", "ECT") %>%
      factor(., levels = c("AIUP", "ECT")),
    Correct = Group == Prediction
  )
}
internal_labeled_predictions <- label_predictions(
  internal_predictions, internal_rocr_threshold
)
external_labeled_predictions <- label_predictions(
  external_predictions, external_rocr_threshold
)

# Plot the performance metric (MCC).
plot_performance <- function(rocr_performance, rocr_threshold){
  df <- tibble::tibble(
    Threshold = rocr_performance@x.values[[1]],
    MCC = rocr_performance@y.values[[1]]
  )
  ggplot()+
    geom_vline(
      xintercept = rocr_threshold$Threshold,
      colour = "red", size = 0.8, linetype = "dashed"
    )+
    geom_hline(
      yintercept = 0,
      colour = "gray", size = 0.8
    )+
    geom_line(
      data = df,
      mapping = aes(Threshold, MCC)
    )+
    geom_point(
      data = df,
      mapping = aes(Threshold, MCC)
    )+
    coord_cartesian(xlim = c(0,1), ylim = c(-1,1), expand = FALSE)+
    panel_border(colour = "black", size = 1.2)+
    scale_x_continuous(
      breaks = seq(0,1,0.2),
      labels = seq(0,1,0.2)
    )+
    scale_y_continuous(
      breaks = seq(-1,1,0.5),
      labels = seq(-1,1,0.5)
    )
}

plt <- plot_performance(internal_rocr_performance, internal_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Internal_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_performance(external_rocr_performance, external_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "External_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot an ROC curve.
plot_roc <- function(df, rocr_threshold, show_threshold = TRUE){
  roc_obj <- pROC::roc(
    response = as.numeric(df$Group) - 1,
    predictor = df$Probability
  )
  roc_df <- tibble::tibble(
    sensitivity = roc_obj$sensitivities,
    `1-specificity` = 1-roc_obj$specificities
  )
  threshold_indices <- c(
    tail(which(roc_obj$thresholds <= rocr_threshold$Threshold), 1),
    head(which(roc_obj$thresholds >= rocr_threshold$Threshold), 1)
  )
  plt <- ggplot()+
    geom_path(
      data = roc_df,
      mapping = aes(`1-specificity`, sensitivity)
    )+
    coord_equal(xlim = c(0,1), ylim = c(0,1))+
    panel_border(colour = "black", size = 1.2)+
    geom_segment(
      aes(
        x = 0, y = 0,
        xend = 1, yend = 1
      ),
      colour = "black", linetype = "dashed", size = 0.5, alpha = 0.4
    )+
    xlab("1 - Specificity")+ylab("Sensitivity")
  if(show_threshold){
    if(length(threshold_indices) == 1){
      plt <- plt+
        geom_point(
          data = tibble::tibble(
            sensitivity = roc_obj$sensitivities[threshold_indices][1],
            `1-specificity` = (1-roc_obj$specificities)[threshold_indices][1]
          ),
          mapping = aes(`1-specificity`, sensitivity),
          colour = "#ff4d4d", size = 1.5
        )
    }
    if(length(threshold_indices) == 2){
      seg_ends <- tibble::tibble(
        sensitivity = roc_obj$sensitivities[threshold_indices],
        `1-specificity` = (1-roc_obj$specificities)[threshold_indices]
      )
      plt <- plt+
        geom_segment(
          mapping = aes(
            x = seg_ends$`1-specificity`[1], y = seg_ends$sensitivity[1],
            xend = seg_ends$`1-specificity`[2], yend = seg_ends$sensitivity[2]
          ),
          colour = "#ff4d4d", size = 1.5
        )
    }
  }
  plt
}

plt <- plot_roc(
  internal_predictions, internal_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Internal_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)
plt <- plot_roc(
  external_predictions, external_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "External_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Plot multiple ROC curves in one figure.
plot_multiple_roc <- function(data_list, show_threshold = TRUE){
  # Initialize the plot.
  plt <- ggplot()+
    coord_equal(xlim = c(0,1), ylim = c(0,1))+
    panel_border(colour = "black", size = 1.2)+
    geom_segment(
      aes(
        x = 0, y = 0,
        xend = 1, yend = 1
      ),
      colour = "black", linetype = "dashed", size = 0.5, alpha = 0.4
    )+
    xlab("1 - Specificity")+ylab("Sensitivity")
  
  # Add elements for each ROC curve.
  threshold_tbl <- tibble::tibble()
  threshold_points_tbl <- tibble::tibble()
  for(group in names(data_list)){
    roc_obj <- pROC::roc(
      response = as.numeric(data_list[[group]]$df$Group) - 1,
      predictor = data_list[[group]]$df$Probability
    )
    roc_df <- tibble::tibble(
      sensitivity = roc_obj$sensitivities,
      `1-specificity` = 1-roc_obj$specificities
    )
    threshold_indices <- c(
      tail(which(roc_obj$thresholds <= 
                   data_list[[group]]$rocr_threshold$Threshold), 1),
      head(which(roc_obj$thresholds >= 
                   data_list[[group]]$rocr_threshold$Threshold), 1)
    ) %>% sort()
    plt <- plt+
      geom_path(
        data = roc_df,
        mapping = aes(`1-specificity`, sensitivity),
        colour = data_list[[group]]$colour,
        size = 1.2
      )
    if(show_threshold){
      if(length(threshold_indices) == 1){
        threshold_points_tbl <- dplyr::bind_rows(
          threshold_points_tbl,
          tibble::tibble(
            x = (1-roc_obj$specificities)[threshold_indices][1],
            y = roc_obj$sensitivities[threshold_indices][1]
          )
        )
      }
      if(length(threshold_indices) == 2){
        seg_ends <- tibble::tibble(
          sensitivity = roc_obj$sensitivities[threshold_indices],
          `1-specificity` = (1-roc_obj$specificities)[threshold_indices]
        )
        threshold_tbl <- dplyr::bind_rows(
          threshold_tbl,
          tibble::tibble(
            x = seg_ends$`1-specificity`[1],
            y = seg_ends$sensitivity[1],
            xend = seg_ends$`1-specificity`[2],
            yend = seg_ends$sensitivity[2]
          )
        )
      }
    }
  }
  if(show_threshold){
    if(nrow(threshold_tbl) > 0){
      plt <- plt+
        geom_segment(
          data = threshold_tbl,
          mapping = aes(x = x, y = y, xend = xend, yend = yend),
          colour = "black", size = 1.5
        )
    }
    if(nrow(threshold_points_tbl) > 0){
      plt <- plt+
        geom_point(
          data = threshold_points_tbl,
          mapping = aes(x, y),
          colour = "black", size = 1.5
        )
    }
  }
  colour_values <- sapply(data_list, function(x){x[["colour"]]})
  plt+
    geom_line(
      data = tibble::tibble(
        group = factor(rep(names(data_list),2), levels = names(data_list)),
        x = rep(c(-1,-2), each = length(data_list)),
        y = rep(c(-1,-2), each = length(data_list))
      ),
      mapping = aes(x, y, colour = group),
      show.legend = TRUE,
      size = 1.2
    )+
    scale_colour_manual(
      name = "Legend",
      values = colour_values
    )+
    theme(
      legend.position = "right",
      legend.title = element_blank()
    )
}
plt <- plot_multiple_roc(
  list(
    "Internal" = list("df" = internal_predictions, 
                      "rocr_threshold" = internal_rocr_threshold,
                      "colour" = "#ff4d4d"),
    "External" = list("df" = external_predictions, 
                      "rocr_threshold" = external_rocr_threshold,
                      "colour" = "#0099ff")
  ),
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Merged_ROC.tiff"),
  plt,
  base_width = 5.5, base_height = 4
)

# Retrieve ROC curve-related statistics.
get_roc_stats <- function(df, rocr_threshold){
  roc_obj <- pROC::roc(
    response = as.numeric(df$Group) - 1,
    predictor = df$Probability
  )
  threshold_indices <- c(
    tail(which(roc_obj$thresholds <= rocr_threshold$Threshold), 1),
    head(which(roc_obj$thresholds >= rocr_threshold$Threshold), 1)
  )
  sensitivity <- mean(roc_obj$sensitivities[threshold_indices])
  specificity <- mean(roc_obj$specificities[threshold_indices])
  auc <- pROC::ci.auc(roc_obj)
  se <- pROC::ci.se(roc_obj, specificities = specificity)
  se <- se[1:3]
  sp <- pROC::ci.sp(roc_obj, sensitivities = sensitivity)
  sp <- sp[1:3]
  
  out <- tibble::tibble(
    auc = paste0(
      signif(median(auc), 2), " (", signif(min(auc), 2), ", ", 
      signif(max(auc), 2), ")"
    ),
    se = paste0(
      signif(median(se), 2), " (", signif(min(se), 2), ", ", 
      signif(max(se), 2), ")"
    ),
    sp = paste0(
      signif(median(sp), 2), " (", signif(min(sp), 2), ", ", 
      signif(max(sp), 2), ")"
    )
  )
  out
}

internal_roc_stats <- get_roc_stats(
  internal_predictions, internal_rocr_threshold
)
writexl::write_xlsx(
  internal_roc_stats,
  file.path("Results", "Internal_ROC_Stats.xlsx")
)
external_roc_stats <- get_roc_stats(
  external_predictions, external_rocr_threshold
)
writexl::write_xlsx(
  external_roc_stats,
  file.path("Results", "External_ROC_Stats.xlsx")
)

# Calculate accuracy on boostrapped samples.
sample_accuracy <- function(df, num_trials, SEED = 123456789){
  set.seed(SEED)
  num_correct <- sum(df$Correct)
  num_wrong <- nrow(df)-num_correct
  rbeta(num_trials, shape1 = num_correct, shape2 = num_wrong)
}

num_trials <- 100000
internal_sampled_accuracy <- sample_accuracy(
  internal_labeled_predictions, num_trials
)
external_sampled_accuracy <- sample_accuracy(
  external_labeled_predictions, num_trials
)

# Use the bootstrap results above to calculate the accuracy CI.
get_accuracy_ci <- function(sampled_accuracy, confidence_level = 0.95){
  low_q <- (1-confidence_level)/2
  high_q <- 1-low_q
  MEAN <- mean(sampled_accuracy)
  quantiles <- quantile(sampled_accuracy, c(low_q, high_q))
  LOW <- quantiles[1]
  HIGH <- quantiles[2]
  tibble::tibble(
    accuracy = paste0(
      signif(MEAN, 2), " (", signif(LOW, 2), ", ", signif(HIGH, 2), ")"
    )
  )
}

internal_accuracy_ci <- get_accuracy_ci(
  internal_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  internal_accuracy_ci,
  file.path("Results", "Internal_Accuracy_CI.xlsx")
)
external_accuracy_ci <- get_accuracy_ci(
  external_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  external_accuracy_ci,
  file.path("Results", "External_Accuracy_CI.xlsx")
)

# Plot the accuracy CI.
plot_accuracy_ci <- function(sampled_accuracy, accuracy_ci){
  accuracy_points <- strsplit(accuracy_ci$accuracy, " |, ")[[1]] %>%
    gsub("\\(","",.) %>%
    gsub("\\)","",.) %>%
    as.numeric()
  value_counts <- table(sampled_accuracy) %>%
    tibble::enframe() %>%
    dplyr::rename(Accuracy = "name", Counts = "value") %>%
    dplyr::mutate(
      Counts = as.vector(Counts),
      Accuracy = as.numeric(Accuracy)
    ) %>%
    dplyr::arrange(Accuracy) %>%
    dplyr::mutate(Density = Counts/sum(Counts))
  ggplot()+
    geom_ribbon(
      data = tibble::tibble(
        x = c(accuracy_points[2], accuracy_points[3]),
        ymin = 0, ymax = Inf
      ),
      mapping = aes(x, ymin = ymin, ymax = ymax),
      fill = "#6E6E6E", alpha = 0.2
    )+
    geom_histogram(
      data = value_counts,
      mapping = aes(Accuracy, y = ..density..),
      fill = "#6BC4FF", alpha = 1,
      bins = 1000
    )+
    geom_vline(
      xintercept = accuracy_points[1],
      colour = "red", size = 1.2
    )+
    geom_vline(
      xintercept = accuracy_points[2],
      colour = "black", size = 0.8, linetype = "dashed"
    )+
    geom_vline(
      xintercept = accuracy_points[3],
      colour = "black", size = 0.8, linetype = "dashed"
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab("Accuracy (%)")+ylab("Probability Density")+
    coord_cartesian(xlim = c(0,1))+
    scale_x_continuous(
      breaks = seq(0,1,0.25),
      labels = seq(0,100, 25),
      expand = expand_scale(mult = c(0,0), add = c(0,0))
    )+
    scale_y_continuous(
      expand = expand_scale(
        mult = c(0,0.1),
        add = c(0,0)
      )
    )+
    theme(
      plot.margin = margin(r = 0.5, unit = "cm")
    )
}

plt <- plot_accuracy_ci(internal_sampled_accuracy, internal_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Internal_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_accuracy_ci(external_sampled_accuracy, external_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "External_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Define a function for making predictions on a second data set.
partition_predictor <- function(df1, df2, cv){
  mat1 <- df1 %>%
    dplyr::select(-Group) %>%
    as.matrix()
  mat2 <- df2 %>%
    dplyr::select(-Group) %>%
    as.matrix()
  fit_internal <- glmnet::glmnet(
        x = mat1,
        y = df1$Group,
        family = "binomial",
        alpha = 0,
        lambda = cv$lambda.min
      )
  probs <- predict(
    fit_internal,
    newx = mat2,
    type = "response"
  ) %>% as.vector()
  dplyr::mutate(
    df2,
    Probability = probs
  ) %>%
    tibble::as_tibble()
}

# Perform PCA and plot the results.
plot_pca_probs <- function(df, cv, rocr_threshold){
  cols_to_exclude <- "Group"
  df_wo_groups <- df[,!(colnames(df) %in% cols_to_exclude)]
  col_means <- colMeans(df_wo_groups)
  for(i in 1:ncol(df_wo_groups)){
    df_wo_groups[[i]] <- df_wo_groups[[i]]-col_means[i]
  }
  pca <- FactoMineR::PCA(
    df_wo_groups, ncp = ncol(df_wo_groups), graph = FALSE,
    scale.unit = FALSE
  )
  df_plt <- tibble::tibble(
    Group = df$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  x_range <- range(df_plt$PC1)
  x_mid <- mean(x_range)
  y_range <- range(df_plt$PC2)
  y_mid <- mean(y_range)
  
  x_range <- diff(x_range)
  y_range <- diff(y_range)
  
  x_low <- x_mid-x_range/2*1.1
  x_hi <- x_mid+x_range/2*1.1
  y_low <- y_mid-y_range/2*1.1
  y_hi <- y_mid+y_range/2*1.1
  
  res <- 1000
  
  pc_values <- expand.grid(
    "PC1" = seq(x_low, x_hi, length.out = res),
    "PC2" = seq(y_low, y_hi, length.out = res)
  ) %>%
    tibble::as_tibble()
  
  pc_mat <- as.matrix(pc_values)
  
  hat <- pc_mat %*% t(pca$svd$V[,1:2])
  colnames(hat) <- colnames(df_wo_groups)
  
  fit_internal <- glmnet::glmnet(
    x = as.matrix(df_wo_groups),
    y = df$Group,
    family = "binomial",
    alpha = 0,
    lambda = cv$lambda.min
  )
  probs <- predict(
    fit_internal,
    newx = hat,
    type = "response"
  ) %>% as.vector()
  pc_values <- dplyr::mutate(
    pc_values,
    Probability = probs
  ) %>%
    tibble::as_tibble()
  cutoff <- 0.01
  threshold_df <- dplyr::filter(
    pc_values,
    abs(Probability - rocr_threshold$Threshold) < cutoff
  )
  
  boundary_fit <- lm(PC2 ~ PC1, data = threshold_df)
  col_getter <- colorRampPalette(c("white","black"))
  
  ggplot()+
    coord_fixed(expand = FALSE)+
    geom_tile(
      data = pc_values,
      mapping = aes(PC1, PC2, fill = Probability)
    )+
    # scale_fill_gradient(low = "white", high = "green")+
    scale_fill_gradientn(
      colours = col_getter(1000),
      na.value = "transparent",
      breaks = c(0,0.5,1),
      labels = c(0,0.5,1),
      limits = c(0,1)
    )+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_abline(
      intercept = boundary_fit$coefficients[1],
      slope = boundary_fit$coefficients[2],
      show.legend = FALSE,
      colour = "red", size = 0.6, linetype = "dashed"
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )+
    labs(fill = "Ectopic\nProbability", colour = "Location")
}

plt <- plot_pca_probs(
  internal_spread, internal_cv_glmnet, internal_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Internal_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_pca_probs(
  external_spread, external_cv_glmnet, external_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "External_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Output labeled predictions.
internal_labeled <- tidyr::spread(
  internal_all_exprs[,c("Unique_ID","SYMBOL","Expression")],
  SYMBOL, Expression
) %>%
  dplyr::mutate(Group = Biobase::pData(internal_raw)$Group) %>%
  dplyr::inner_join(
    .,
    metadata %>% dplyr::select(Sample, Unique_ID),
    by = "Unique_ID"
  )
external_labeled <- tidyr::spread(
    external_all_exprs[,c("Unique_ID","SYMBOL","Expression")],
    SYMBOL, Expression
) %>%
    dplyr::mutate(Group = Biobase::pData(external_raw)$Group) %>%
  dplyr::inner_join(
    .,
    metadata %>% dplyr::select(Sample, Unique_ID),
    by = "Unique_ID"
  )
writexl::write_xlsx(
  dplyr::bind_rows(
    dplyr::mutate(
      internal_labeled_predictions,
      Unique_ID = internal_labeled$Unique_ID,
      Sample = internal_labeled$Sample,
      Dataset = "Internal"
    ),
    dplyr::mutate(
      external_labeled_predictions,
      Unique_ID = external_labeled$Unique_ID,
      Sample = external_labeled$Sample,
      Dataset = "External"
    )
  ),
  file.path("Results", "Samples.xlsx")
)
```




# Model development with a smaller subset of genes


```{r}
# Subset the genes of interest.
sub_cols <- c(
  "Group",
  
  "C20orf85", "LRRC46", "ZBBX"
)
sub_internal_spread <- internal_spread[,colnames(internal_spread) %in% sub_cols]
sub_external_spread <- external_spread[,colnames(external_spread) %in% sub_cols]

# Perform loocv to identify the optimal lambda.
ln_lambdas_tried <- seq(-10, 10, 0.01)
internal_cv_glmnet <- cv_a_glmnet(internal_spread, ln_lambdas_tried)
external_cv_glmnet <- cv_a_glmnet(external_spread, ln_lambdas_tried)

# Plot the cross validation results.
plt <- plot_cv_glmnet(internal_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Post_Internal_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_cv_glmnet(external_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Post_External_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Extract and save lambda values.
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = internal_cv_glmnet$lambda.min,
    labmda_1se = internal_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Post_Internal_Lambda.xlsx")
)
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = external_cv_glmnet$lambda.min,
    labmda_1se = external_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Post_External_Lambda.xlsx")
)
```


Models were fit using the optimal lambdas.


```{r}
# Make predictions using loocv.
internal_predictions <- loocv_predictor(sub_internal_spread, internal_cv_glmnet)
external_predictions <- loocv_predictor(sub_external_spread, external_cv_glmnet)

# Create an roc prediction object for further processing.
internal_rocr_prediction <- create_roc(internal_predictions)
external_rocr_prediction <- create_roc(external_predictions)

# Create an roc performance object for further processing.
internal_rocr_performance <- create_performance(internal_rocr_prediction)
external_rocr_performance <- create_performance(external_rocr_prediction)

# Determine the threshold that maximizes Mathhew's correlation coefficient
# (MCC).
internal_rocr_threshold <- get_threshold(internal_rocr_performance)
external_rocr_threshold <- get_threshold(external_rocr_performance)

# Use the threshold determined above to label the prediction based on their
# predicted probabilities.
internal_labeled_predictions <- label_predictions(
  internal_predictions, internal_rocr_threshold
)
external_labeled_predictions <- label_predictions(
  external_predictions, external_rocr_threshold
)

# Plot the performance metric (MCC).
plt <- plot_performance(internal_rocr_performance, internal_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Post_Internal_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_performance(external_rocr_performance, external_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Post_External_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot an ROC curve.
plt <- plot_roc(
  internal_predictions, internal_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Post_Internal_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)
plt <- plot_roc(
  external_predictions, external_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Post_External_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Plot multiple ROC curves in one figure.
plt <- plot_multiple_roc(
  list(
    "Internal" = list("df" = internal_predictions, 
                      "rocr_threshold" = internal_rocr_threshold,
                      "colour" = "#ff4d4d"),
    "External" = list("df" = external_predictions, 
                      "rocr_threshold" = external_rocr_threshold,
                      "colour" = "#0099ff")
  ),
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Post_Merged_ROC.tiff"),
  plt,
  base_width = 5.5, base_height = 4
)

# Retrieve ROC curve-related statistics.
internal_roc_stats <- get_roc_stats(
  internal_predictions, internal_rocr_threshold
)
writexl::write_xlsx(
  internal_roc_stats,
  file.path("Results", "Post_Internal_ROC_Stats.xlsx")
)
external_roc_stats <- get_roc_stats(
  external_predictions, external_rocr_threshold
)
writexl::write_xlsx(
  external_roc_stats,
  file.path("Results", "Post_External_ROC_Stats.xlsx")
)

# Calculate accuracy on boostrapped samples.
num_trials <- 100000
internal_sampled_accuracy <- sample_accuracy(
  internal_labeled_predictions, num_trials
)
external_sampled_accuracy <- sample_accuracy(
  external_labeled_predictions, num_trials
)

# Use the bootstrap results above to calculate the accuracy CI.
internal_accuracy_ci <- get_accuracy_ci(
  internal_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  internal_accuracy_ci,
  file.path("Results", "Post_Internal_Accuracy_CI.xlsx")
)
external_accuracy_ci <- get_accuracy_ci(
  external_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  external_accuracy_ci,
  file.path("Results", "Post_External_Accuracy_CI.xlsx")
)

# Plot the accuracy CI.
plt <- plot_accuracy_ci(internal_sampled_accuracy, internal_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Post_Internal_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_accuracy_ci(external_sampled_accuracy, external_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Post_External_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a PCA scatterplot.
plt <- plot_pca_scatter(internal_spread)
cowplot::save_plot(
  file.path("Results", "Post_Internal_PCA.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_pca_scatter(external_spread)
cowplot::save_plot(
  file.path("Results", "Post_External_PCA.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a scree plot.
plt <- plot_pca_scree(internal_spread)
cowplot::save_plot(
  file.path("Results", "Post_Internal_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_pca_scree(external_spread)
cowplot::save_plot(
  file.path("Results", "Post_External_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

plt <- plot_pca_probs(
  internal_spread, internal_cv_glmnet, internal_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Post_Internal_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_pca_probs(
  external_spread, external_cv_glmnet, external_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Post_External_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Output labeled predictions.
writexl::write_xlsx(
  dplyr::bind_rows(
    dplyr::mutate(
      internal_labeled_predictions,
      Unique_ID = rownames(internal_spread),
      Dataset = "Internal"
    ),
    dplyr::mutate(
      external_labeled_predictions,
      Unique_ID = rownames(external_spread),
      Dataset = "External"
    )
  ),
  file.path("Results", "Post_Samples.xlsx")
)
```



# Model development with data partitioning - internal


```{r}
# Perform loocv to identify the optimal lambda.
ln_lambdas_tried <- seq(-20, 20, 0.01)

are_aiup <- which(internal_spread$Group == "AIUP")
are_ect <- which(internal_spread$Group == "ECT")

set.seed(123456789)

train_indices <- c(
  sample(are_aiup, length(are_aiup)/2),
  sample(are_ect, length(are_ect)/2)
)

train_spread <- internal_spread[train_indices,]
test_spread <- internal_spread[-train_indices,]

train_cv_glmnet <- cv_a_glmnet(train_spread, ln_lambdas_tried)

# Plot the cross validation results.
plt <- plot_cv_glmnet(train_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Extract and save lambda values.
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = train_cv_glmnet$lambda.min,
    labmda_1se = train_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Partition_Internal_Train_Lambda.xlsx")
)
```


Models were fit using the optimal lambdas.


```{r}
# Make predictions.
train_predictions <- loocv_predictor(train_spread, train_cv_glmnet)
test_predictions <- partition_predictor(
  train_spread, test_spread, train_cv_glmnet
)

# Create an roc prediction object for further processing.
train_rocr_prediction <- create_roc(train_predictions)
test_rocr_prediction <- create_roc(test_predictions)

# Create an roc performance object for further processing.
train_rocr_performance <- create_performance(train_rocr_prediction)
test_rocr_performance <- create_performance(test_rocr_prediction)

# Determine the threshold that maximizes Mathhew's correlation coefficient
# (MCC).
train_rocr_threshold <- get_threshold(train_rocr_performance)
test_rocr_threshold <- get_threshold(test_rocr_performance)

# Use the threshold determined above to label the prediction based on their
# predicted probabilities.
train_labeled_predictions <- label_predictions(
  train_predictions, train_rocr_threshold
)
test_labeled_predictions <- label_predictions(
  test_predictions, train_rocr_threshold
)

# Plot the performance metric (MCC).
plt <- plot_performance(train_rocr_performance, train_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_performance(test_rocr_performance, train_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Test_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot an ROC curve.
plt <- plot_roc(
  train_predictions, train_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)
plt <- plot_roc(
  test_predictions, test_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Post_Test_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Plot multiple ROC curves in one figure.
plt <- plot_multiple_roc(
  list(
    "Train" = list("df" = train_predictions, 
                   "rocr_threshold" = train_rocr_threshold,
                   "colour" = "#ff4d4d"),
    "Test" = list("df" = test_predictions, 
                  "rocr_threshold" = train_rocr_threshold,
                  "colour" = "#0099ff")
  ),
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Merged_ROC.tiff"),
  plt,
  base_width = 5.5, base_height = 4
)

# Retrieve ROC curve-related statistics.
train_roc_stats <- get_roc_stats(
  train_predictions, train_rocr_threshold
)
writexl::write_xlsx(
  train_roc_stats,
  file.path("Results", "Partition_Internal_Train_ROC_Stats.xlsx")
)
test_roc_stats <- get_roc_stats(
  test_predictions, train_rocr_threshold
)
writexl::write_xlsx(
  test_roc_stats,
  file.path("Results", "Partition_Internal_Test_ROC_Stats.xlsx")
)

# Calculate accuracy on boostrapped samples.
num_trials <- 100000
train_sampled_accuracy <- sample_accuracy(
  train_labeled_predictions, num_trials
)
test_sampled_accuracy <- sample_accuracy(
  test_labeled_predictions, num_trials
)

# Use the bootstrap results above to calculate the accuracy CI.
train_accuracy_ci <- get_accuracy_ci(
  train_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  train_accuracy_ci,
  file.path("Results", "Partition_Internal_Train_Accuracy_CI.xlsx")
)
test_accuracy_ci <- get_accuracy_ci(
  test_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  test_accuracy_ci,
  file.path("Results", "Partition_Internal_Test_Accuracy_CI.xlsx")
)

# Plot the accuracy CI.
plt <- plot_accuracy_ci(train_sampled_accuracy, train_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Train_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_accuracy_ci(test_sampled_accuracy, test_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_Test_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a scree plot.
plt <- plot_pca_scree(train_spread)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)



# Perform PCA and plot the results.
plot_multiple_pca_probs <- function(df1, df2, cv, rocr_threshold){
  cols_to_exclude <- "Group"
  df1_wo_groups <- df1[,!(colnames(df1) %in% cols_to_exclude)]
  df2_wo_groups <- df2[,!(colnames(df2) %in% cols_to_exclude)]
  col_means <- colMeans(df1_wo_groups)
  for(i in 1:ncol(df1_wo_groups)){
    df1_wo_groups[[i]] <- df1_wo_groups[[i]]-col_means[i]
    df2_wo_groups[[i]] <- df2_wo_groups[[i]]-col_means[i]
  }
  pca <- FactoMineR::PCA(
    df1_wo_groups, ncp = ncol(df1_wo_groups), graph = FALSE,
    scale.unit = FALSE
  )
  df1_plt <- tibble::tibble(
    Group = df1$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  pca2 <- FactoMineR::predict.PCA(pca, df2_wo_groups)
  df2_plt <- tibble::tibble(
    Group = df2$Group,
    PC1 = pca2$coord[,1],
    PC2 = pca2$coord[,2]
  )
  
  df_plt <- dplyr::bind_rows(
    dplyr::mutate(df1_plt, Dataset = "Train"),
    dplyr::mutate(df2_plt, Dataset = "Test")
  ) %>%
    dplyr::mutate(Dataset = factor(Dataset, levels = c("Train", "Test")))
  
  x_range <- range(df_plt$PC1)
  x_mid <- mean(x_range)
  y_range <- range(df_plt$PC2)
  y_mid <- mean(y_range)
  
  x_range <- diff(x_range)
  y_range <- diff(y_range)
  
  x_low <- x_mid-x_range/2*1.1
  x_hi <- x_mid+x_range/2*1.1
  y_low <- y_mid-y_range/2*1.1
  y_hi <- y_mid+y_range/2*1.1
  
  res <- 1000
  
  pc_values <- expand.grid(
    "PC1" = seq(x_low, x_hi, length.out = res),
    "PC2" = seq(y_low, y_hi, length.out = res)
  ) %>%
    tibble::as_tibble()
  
  pc_mat <- as.matrix(pc_values)
  
  hat <- pc_mat %*% t(pca$svd$V[,1:2])
  colnames(hat) <- colnames(df1_wo_groups)
  
  fit_internal <- glmnet::glmnet(
    x = as.matrix(df1_wo_groups),
    y = df1$Group,
    family = "binomial",
    alpha = 0,
    lambda = cv$lambda.min
  )
  probs <- predict(
    fit_internal,
    newx = hat,
    type = "response"
  ) %>% as.vector()
  pc_values <- dplyr::mutate(
    pc_values,
    Probability = probs
  ) %>%
    tibble::as_tibble()
  cutoff <- 0.01
  threshold_df <- dplyr::filter(
    pc_values,
    abs(Probability - rocr_threshold$Threshold) < cutoff
  )
  
  boundary_fit <- lm(PC2 ~ PC1, data = threshold_df)
  col_getter <- colorRampPalette(c("white","black"))
  
  ggplot()+
    coord_fixed(expand = FALSE)+
    geom_tile(
      data = pc_values,
      mapping = aes(PC1, PC2, fill = Probability)
    )+
    # scale_fill_gradient(low = "white", high = "green")+
    scale_fill_gradientn(
      colours = col_getter(1000),
      na.value = "transparent",
      breaks = c(0,0.5,1),
      labels = c(0,0.5,1),
      limits = c(0,1)
    )+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_abline(
      intercept = boundary_fit$coefficients[1],
      slope = boundary_fit$coefficients[2],
      show.legend = FALSE,
      colour = "red", size = 0.6, linetype = "dashed"
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group, shape = Dataset)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )+
    labs(fill = "Ectopic\nProbability", colour = "Location")
}

plt <- plot_multiple_pca_probs(
  train_spread, test_spread, train_cv_glmnet, train_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4.5
)

# Perform PCA and plot the results.
plot_multiple_pca_scatter <- function(df1, df2){
  cols_to_exclude <- "Group"
  df1_wo_groups <- df1[,!(colnames(df1) %in% cols_to_exclude)]
  df2_wo_groups <- df2[,!(colnames(df2) %in% cols_to_exclude)]
  col_means <- colMeans(df1_wo_groups)
  for(i in 1:ncol(df1_wo_groups)){
    df1_wo_groups[[i]] <- df1_wo_groups[[i]]-col_means[i]
    df2_wo_groups[[i]] <- df2_wo_groups[[i]]-col_means[i]
  }
  pca <- FactoMineR::PCA(
    df1_wo_groups, ncp = ncol(df1_wo_groups), graph = FALSE,
    scale.unit = FALSE
  )
  df1_plt <- tibble::tibble(
    Group = df1$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  pca2 <- FactoMineR::predict.PCA(pca, df2_wo_groups)
  df2_plt <- tibble::tibble(
    Group = df2$Group,
    PC1 = pca2$coord[,1],
    PC2 = pca2$coord[,2]
  )
  
  df_plt <- dplyr::bind_rows(
    dplyr::mutate(df1_plt, Dataset = "Train"),
    dplyr::mutate(df2_plt, Dataset = "Test")
  ) %>%
    dplyr::mutate(Dataset = factor(Dataset, levels = c("Train", "Test")))
  
  x_range <- range(df_plt$PC1)
  x_mid <- mean(x_range)
  y_range <- range(df_plt$PC2)
  y_mid <- mean(y_range)
  
  x_range <- diff(x_range)
  y_range <- diff(y_range)
  
  x_low <- x_mid-x_range/2*1.1
  x_hi <- x_mid+x_range/2*1.1
  y_low <- y_mid-y_range/2*1.1
  y_hi <- y_mid+y_range/2*1.1
  
  ggplot()+
    coord_fixed(expand = FALSE)+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group, shape = Dataset)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )+
    labs(fill = "Ectopic\nProbability", colour = "Location")
}

plt <-  plot_multiple_pca_scatter(
  train_spread, test_spread
)
cowplot::save_plot(
  file.path("Results", "Partition_Internal_PCA_Scatter.tiff"),
  plt,
  base_width = 6.5, base_height = 4.5
)

# Output labeled predictions.
writexl::write_xlsx(
  dplyr::bind_rows(
    dplyr::mutate(
      train_labeled_predictions,
      Unique_ID = rownames(train_spread),
      Dataset = "Train"
    ),
    dplyr::mutate(
      test_labeled_predictions,
      Unique_ID = rownames(test_spread),
      Dataset = "Test"
    )
  ),
  file.path("Results", "Partition_Internal_Samples.xlsx")
)
```


# Model development with data partitioning - external


```{r}
# Perform loocv to identify the optimal lambda.
ln_lambdas_tried <- seq(-20, 20, 0.01)

are_aiup <- which(external_spread$Group == "AIUP")
are_ect <- which(external_spread$Group == "ECT")

set.seed(123456789)

train_indices <- c(
  sample(are_aiup, length(are_aiup)/2),
  sample(are_ect, length(are_ect)/2)
)

train_spread <- external_spread[train_indices,]
test_spread <- external_spread[-train_indices,]

train_cv_glmnet <- cv_a_glmnet(train_spread, ln_lambdas_tried)

# Plot the cross validation results.
plt <- plot_cv_glmnet(train_cv_glmnet, ln_lambdas_tried)
cowplot::save_plot(
  file.path("Results", "Partition_External_Train_Lambda_Selection.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Extract and save lambda values.
writexl::write_xlsx(
  tibble::tibble(
    lambda_min = train_cv_glmnet$lambda.min,
    labmda_1se = train_cv_glmnet$lambda.1se
  ),
  file.path("Results", "Partition_External_Train_Lambda.xlsx")
)
```


Models were fit using the optimal lambdas.


```{r}
# Make predictions.
train_predictions <- loocv_predictor(train_spread, train_cv_glmnet)
test_predictions <- partition_predictor(
  train_spread, test_spread, train_cv_glmnet
)

# Create an roc prediction object for further processing.
train_rocr_prediction <- create_roc(train_predictions)
test_rocr_prediction <- create_roc(test_predictions)

# Create an roc performance object for further processing.
train_rocr_performance <- create_performance(train_rocr_prediction)
test_rocr_performance <- create_performance(test_rocr_prediction)

# Determine the threshold that maximizes Mathhew's correlation coefficient
# (MCC).
train_rocr_threshold <- get_threshold(train_rocr_performance)
test_rocr_threshold <- get_threshold(test_rocr_performance)

# Use the threshold determined above to label the prediction based on their
# predicted probabilities.
train_labeled_predictions <- label_predictions(
  train_predictions, train_rocr_threshold
)
test_labeled_predictions <- label_predictions(
  test_predictions, train_rocr_threshold
)

# Plot the performance metric (MCC).
plt <- plot_performance(train_rocr_performance, train_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Partition_External_Train_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_performance(test_rocr_performance, train_rocr_threshold)
cowplot::save_plot(
  file.path("Results", "Partition_External_Test_MCC.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Plot an ROC curve.
plt <- plot_roc(
  train_predictions, train_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Partition_External_Train_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)
plt <- plot_roc(
  test_predictions, test_rocr_threshold,
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Post_Test_ROC.tiff"),
  plt,
  base_width = 4, base_height = 4
)

# Plot multiple ROC curves in one figure.
plt <- plot_multiple_roc(
  list(
    "Train" = list("df" = train_predictions, 
                   "rocr_threshold" = train_rocr_threshold,
                   "colour" = "#ff4d4d"),
    "Test" = list("df" = test_predictions, 
                  "rocr_threshold" = train_rocr_threshold,
                  "colour" = "#0099ff")
  ),
  show_threshold = TRUE
)
cowplot::save_plot(
  file.path("Results", "Partition_External_Merged_ROC.tiff"),
  plt,
  base_width = 5.5, base_height = 4
)

# Retrieve ROC curve-related statistics.
train_roc_stats <- get_roc_stats(
  train_predictions, train_rocr_threshold
)
writexl::write_xlsx(
  train_roc_stats,
  file.path("Results", "Partition_External_Train_ROC_Stats.xlsx")
)
test_roc_stats <- get_roc_stats(
  test_predictions, train_rocr_threshold
)
writexl::write_xlsx(
  test_roc_stats,
  file.path("Results", "Partition_External_Test_ROC_Stats.xlsx")
)

# Calculate accuracy on boostrapped samples.
num_trials <- 100000
train_sampled_accuracy <- sample_accuracy(
  train_labeled_predictions, num_trials
)
test_sampled_accuracy <- sample_accuracy(
  test_labeled_predictions, num_trials
)

# Use the bootstrap results above to calculate the accuracy CI.
train_accuracy_ci <- get_accuracy_ci(
  train_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  train_accuracy_ci,
  file.path("Results", "Partition_External_Train_Accuracy_CI.xlsx")
)
test_accuracy_ci <- get_accuracy_ci(
  test_sampled_accuracy, confidence_level = 0.95
)
writexl::write_xlsx(
  test_accuracy_ci,
  file.path("Results", "Partition_External_Test_Accuracy_CI.xlsx")
)

# Plot the accuracy CI.
plt <- plot_accuracy_ci(train_sampled_accuracy, train_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Partition_External_Train_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)
plt <- plot_accuracy_ci(test_sampled_accuracy, test_accuracy_ci)
cowplot::save_plot(
  file.path("Results", "Partition_External_Test_Accuracy_CI.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)

# Generate a scree plot.
plt <- plot_pca_scree(train_spread)
cowplot::save_plot(
  file.path("Results", "Partition_External_PCA_Scree.tiff"),
  plt,
  base_width = 6.5, base_height = 4
)



# Perform PCA and plot the results.
plot_multiple_pca_probs <- function(df1, df2, cv, rocr_threshold){
  cols_to_exclude <- "Group"
  df1_wo_groups <- df1[,!(colnames(df1) %in% cols_to_exclude)]
  df2_wo_groups <- df2[,!(colnames(df2) %in% cols_to_exclude)]
  col_means <- colMeans(df1_wo_groups)
  for(i in 1:ncol(df1_wo_groups)){
    df1_wo_groups[[i]] <- df1_wo_groups[[i]]-col_means[i]
    df2_wo_groups[[i]] <- df2_wo_groups[[i]]-col_means[i]
  }
  pca <- FactoMineR::PCA(
    df1_wo_groups, ncp = ncol(df1_wo_groups), graph = FALSE,
    scale.unit = FALSE
  )
  df1_plt <- tibble::tibble(
    Group = df1$Group,
    PC1 = pca$ind$coord[,1],
    PC2 = pca$ind$coord[,2]
  )
  pc1_var <- round(pca$eig[1,"percentage of variance"], 1)
  pc1_mod <- pc1_var %% 1
  pc1_mod <- signif(pc1_mod, 1)
  pc1_mod <- substr(as.character(pc1_mod*10), 1, 1)
  pc1_var <- paste0(trunc(pc1_var), ".", pc1_mod)
  pc1_label <- paste0(
    "PC1 (", pc1_var, "%)"
  )
  pc2_var <- round(pca$eig[2,"percentage of variance"], 1)
  pc2_mod <- pc2_var %% 1
  pc2_mod <- signif(pc2_mod, 1)
  pc2_mod <- substr(as.character(pc2_mod*10), 1, 1)
  pc2_var <- paste0(trunc(pc2_var), ".", pc2_mod)
  pc2_label <- paste0(
    "PC2 (", pc2_var, "%)"
  )
  
  pca2 <- FactoMineR::predict.PCA(pca, df2_wo_groups)
  df2_plt <- tibble::tibble(
    Group = df2$Group,
    PC1 = pca2$coord[,1],
    PC2 = pca2$coord[,2]
  )
  
  df_plt <- dplyr::bind_rows(
    dplyr::mutate(df1_plt, Dataset = "Train"),
    dplyr::mutate(df2_plt, Dataset = "Test")
  ) %>%
    dplyr::mutate(Dataset = factor(Dataset, levels = c("Train", "Test")))
  
  x_range <- range(df_plt$PC1)
  x_mid <- mean(x_range)
  y_range <- range(df_plt$PC2)
  y_mid <- mean(y_range)
  
  x_range <- diff(x_range)
  y_range <- diff(y_range)
  
  x_low <- x_mid-x_range/2*1.1
  x_hi <- x_mid+x_range/2*1.1
  y_low <- y_mid-y_range/2*1.1
  y_hi <- y_mid+y_range/2*1.1
  
  res <- 1000
  
  pc_values <- expand.grid(
    "PC1" = seq(x_low, x_hi, length.out = res),
    "PC2" = seq(y_low, y_hi, length.out = res)
  ) %>%
    tibble::as_tibble()
  
  pc_mat <- as.matrix(pc_values)
  
  hat <- pc_mat %*% t(pca$svd$V[,1:2])
  colnames(hat) <- colnames(df1_wo_groups)
  
  fit_internal <- glmnet::glmnet(
    x = as.matrix(df1_wo_groups),
    y = df1$Group,
    family = "binomial",
    alpha = 0,
    lambda = cv$lambda.min
  )
  probs <- predict(
    fit_internal,
    newx = hat,
    type = "response"
  ) %>% as.vector()
  pc_values <- dplyr::mutate(
    pc_values,
    Probability = probs
  ) %>%
    tibble::as_tibble()
  cutoff <- 0.01
  threshold_df <- dplyr::filter(
    pc_values,
    abs(Probability - rocr_threshold$Threshold) < cutoff
  )
  
  boundary_fit <- lm(PC2 ~ PC1, data = threshold_df)
  col_getter <- colorRampPalette(c("white","black"))
  
  ggplot()+
    coord_fixed(expand = FALSE)+
    geom_tile(
      data = pc_values,
      mapping = aes(PC1, PC2, fill = Probability)
    )+
    # scale_fill_gradient(low = "white", high = "green")+
    scale_fill_gradientn(
      colours = col_getter(1000),
      na.value = "transparent",
      breaks = c(0,0.5,1),
      labels = c(0,0.5,1),
      limits = c(0,1)
    )+
    geom_hline(
      yintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_vline(
      xintercept = 0,
      colour = "black", size = 0.6, linetype = "dashed", alpha = 0.5
    )+
    geom_abline(
      intercept = boundary_fit$coefficients[1],
      slope = boundary_fit$coefficients[2],
      show.legend = FALSE,
      colour = "red", size = 0.6, linetype = "dashed"
    )+
    geom_point(
      data = df_plt,
      mapping = aes(PC1, PC2, colour = Group, shape = Dataset)
    )+
    panel_border(colour = "black", size = 1.2)+
    xlab(pc1_label)+ylab(pc2_label)+
    scale_colour_manual(
      values = c("#ff4d4d", "#0099ff")
    )+
    labs(fill = "Ectopic\nProbability", colour = "Location")
}

plt <- plot_multiple_pca_probs(
  train_spread, test_spread, train_cv_glmnet, train_rocr_threshold
)
cowplot::save_plot(
  file.path("Results", "Partition_External_PCA_Probabilities.tiff"),
  plt,
  base_width = 6.5, base_height = 4.5
)

# Plot a PCA scatterplot.
plt <-  plot_multiple_pca_scatter(
  train_spread, test_spread
)
cowplot::save_plot(
  file.path("Results", "Partition_External_PCA_Scatter.tiff"),
  plt,
  base_width = 6.5, base_height = 4.5
)

# Output labeled predictions.
writexl::write_xlsx(
  dplyr::bind_rows(
    dplyr::mutate(
      train_labeled_predictions,
      Unique_ID = rownames(train_spread),
      Dataset = "Train"
    ),
    dplyr::mutate(
      test_labeled_predictions,
      Unique_ID = rownames(test_spread),
      Dataset = "Test"
    )
  ),
  file.path("Results", "Partition_External_Samples.xlsx")
)
```



# Correlations


```{r}
df_forcors <- norms_stacked %>%
  dplyr::select(
    -PUL, -PROBEID, -ENSEMBL
  ) %>%
  tidyr::spread(
    SYMBOL, Expression
  )

ega_data <- readxl::read_excel(file.path("Data","EGA,ZimScores.xlsx"))

cormerged <- dplyr::inner_join(
  df_forcors,
  ega_data %>%
    dplyr::select(-Group, -Data_Source),
  by = "Unique_ID"
)

get_ega_cor <- function(
  df,
  group, geneSymbol
){
  vals_ega <- df$EGA[df[["Group"]] == group]
  vals_gene <- df[[geneSymbol]][df[["Group"]] == group]
  cor.test(vals_ega, vals_gene)
}
get_ega_cors <- function(df, gene_symbols = c(
  "C20orf85","LRRC46","RSPH4A","WDR49","ZBBX"
)){
  out <- tibble::tibble()
  for(group in c("AIUP","ECT")){
    for(geneSymbol in gene_symbols){
      temp <- get_ega_cor(cormerged, group, geneSymbol)
      out <- dplyr::bind_rows(
        out,
        tibble::tibble(
          Group = group,
          Gene = geneSymbol,
          P_Value = temp$p.value,
          Correlation = temp$estimate,
          `2.5 %` = temp$conf.int[1],
          `97.5 %` = temp$conf.int[2]
        )
      )
    }
  }
  out %>%
    dplyr::mutate(
      P_Value = p.adjust(P_Value, method = "fdr")
    )
}

ega_cors <- get_ega_cors(cormerged)
writexl::write_xlsx(
  ega_cors,
  file.path("Results","EGA_Correlations.xlsx")
)

get_zim_cor <- function(
  df,
  group, geneSymbol
){
  vals_zim <- df$Zimmerman[df[["Group"]] == group]
  vals_gene <- df[[geneSymbol]][df[["Group"]] == group]
  cor.test(vals_zim, vals_gene, method = "pearson")
}
get_zim_cors <- function(df, gene_symbols = c(
  "C20orf85","LRRC46","RSPH4A","WDR49","ZBBX"
)){
  out <- tibble::tibble()
  for(group in c("AIUP","ECT")){
    for(geneSymbol in gene_symbols){
      temp <- get_zim_cor(cormerged, group, geneSymbol)
      out <- dplyr::bind_rows(
        out,
        tibble::tibble(
          Group = group,
          Gene = geneSymbol,
          P_Value = temp$p.value,
          Correlation = temp$estimate,
          `2.5 %` = temp$conf.int[1],
          `97.5 %` = temp$conf.int[2]
        )
      )
    }
  }
  out %>%
    dplyr::mutate(
      P_Value = p.adjust(P_Value, method = "fdr")
    )
}

zim_cors <- get_zim_cors(cormerged)
writexl::write_xlsx(
  zim_cors,
  file.path("Results","Zimmerman_Correlations.xlsx")
)
```
